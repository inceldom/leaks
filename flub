local Loaded = false

if game.PlaceId == 2961297129 then
   Loaded = true
   print("FLUX: Game Death Zone.")
       --Made by : https://v3rmillion.net/member.php?action=profile&uid=1591342
    
   local ShowerLib = loadstring(game:HttpGet("https://fluxteam.xyz/scripts/others/ShowerHeadLibrary.lua"))()
   local ESP = loadstring(game:HttpGet"https://raw.githubusercontent.com/dawid-scripts/Helios-Hub/main/Scripts/HeliosESP.lua")()
   local Window = ShowerLib:CreateWindow("F"); --Clicking this will make it rotate.
   local HomePage = Window:Section("Aim")
   local SelfPage = Window:Section("Self")
   local VisualsPage = Window:Section("Visual")
   local MiscPage = Window:Section("Misc")
   ESP:SetESPColor(Color3.fromRGB(0, 166, 255))
   
   
   --Configuration
   --Circle
   local FOVAmount = ""


   --Load settings
   local LightingModuleDeleted = false
   --Configuration
   
   HomePage:AddSlider("FOV", 100, 400, 10, function(Value)
       FOVAmount = Value -- Value is the value of the slider
   end)

   local SelectedBodyPart = "Random"

   HomePage:AddDrop(
           "Aimed Part",
           {
               "Head",
               "Body",
               "Random"
           },
           function(value)
               SelectedBodyPart = value
           end
       )
   
   HomePage:AddToggle("Silent Aim", function(state)
       if state == true then
           -- settings, if you want to change some settings just re-execute.
           _G.whitelist = {
              "ItsIofty"
           }
           _G.friendsListIsWhitelisted = true -- change if you don't want to lock onto your friends
           _G.targetPart = SelectedBodyPart
           _G.bindEnabled = false
           _G.bind = Enum.KeyCode.E -- use the keycode reference: https://developer.roblox.com/en-us/api-reference/enum/KeyCode, this keydisables aimbot
   
           _G.FOV = FOVAmount
   
           -- This is primarily useful in first person shooters, note, wallbang will not work when you disable this.
           local RAYCAST_ENABLED = true
           -- -- This is rarely useful, however in some cases you might want it.
           local MOUSE_TARGET_ENABLED = false
           -- This is useful for most third person shooters.  It will function very well if you're having bugs, switch to mouse position.
           local MOUSE_HIT_ENABLED = false
           -- If you want to spoof the mouse's x and y coordinated on the screen.  usually if it's a 3rd person shooter it will use this or mouse hit.
           local MOUSE_POSITION_ENABLED = false
           -- I'm not sure what you're going to use this for, but it works I guess
           local MOUSE_ORIGIN_ENABLED = false
   
           _G.indexTable = {
              -- mainly for scripters, but basically these are mouse properties that you might want to enable/disable if it's bugging out.
              ["Mouse"] = {
                 ["target"] = {
                    Function = function(self, value)
                    return _G.closestCharacter[_G.targetPart]
                    end,
                    Enabled = MOUSE_TARGET_ENABLED
                 },
                 ["hit"] = {
                    Function = function(self, value)
                    return _G.closestCharacter[_G.targetPart].CFrame
                    end,
                    Enabled = MOUSE_HIT_ENABLED
                 },
                 ["origin"] = {
                    Function = function(self, value)
                    return CFrame.new(value.Position, _G.closestCharacter[_G.targetPart].Position)
                    end,
                    Enabled = MOUSE_ORIGIN_ENABLED
                 },
                 ["x"] = {
                    Function = function(self, value)
                    return uis:GetMouseLocation().X
                    end,
                    Enabled = MOUSE_POSITION_ENABLED
                 },
                 ["y"] = {
                    Function = function(self, value)
                    return uis:GetMouseLocation().Y
                    end,
                    Enabled = MOUSE_POSITION_ENABLED
                 },
                 ["unitray"] = {
                    Function = function(self, value)
                    return Ray.new(
                    self.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position - self.Origin.Position).Unit
                    )
                    end,
                    Enabled = RAYCAST_ENABLED
                 }
              },
              ["Humanoid"] = {
                 ["targetpoint"] = {
                    Function = function(self, value)
                    return _G.closestCharacter[_G.targetPart].Position
                    end,
                    Enabled = MOUSE_HIT_ENABLED
                 }
              }
           }
   
           _G.namecallTable = {
              ["getmouselocation"] = {
                 Function = function(self, returns, args)
                 local vector =
                 workspace.CurrentCamera.WorldToViewportPoint(
                 workspace.CurrentCamera,
                 _G.closestCharacter[_G.targetPart].Position
                 )
                 returns[1] = Vector2.new(vector.X, vector.Y)
                 return returns
                 end,
                 Enabled = MOUSE_POSITION_ENABLED
              },
              ["findpartonraywithignorelist"] = {
                 Function = function(self, returns, args)
                 args[1] =
                 Ray.new(
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
                 )
                 if not _G.wallbang then
                    returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                 else
                    args[2] = {}
                    for _, player in ipairs(game.Players:GetPlayers()) do
                       if player.Character then
                          table.insert(args[2], player.Character)
                       end
                    end
                    returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                 end
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              },
              ["findpartonray"] = {
                 Function = function(self, returns, args)
                 args[1] =
                 Ray.new(
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
                 )
                 if not args[2] then
                    args[2] = {}
                 end
                 if not _G.wallbang then
                    returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                 else
                    args[2] = {}
                    for _, player in ipairs(game.Players:GetPlayers()) do
                       if player.Character then
                          table.insert(args[2], player.Character)
                       end
                    end
                    returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                 end
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              },
              ["findpartonraywithwhitelist"] = {
                 Function = function(self, returns, args)
                 args[1] =
                 Ray.new(
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
                 )
                 if not _G.wallbang then
                    returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                 else
                    for _, player in ipairs(game.Players:GetPlayers()) do
                       if player.Character then
                          table.insert(args[2], player.Character)
                       end
                    end
                    returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                 end
   
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              },
              ["raycast"] = {
                 Function = function(self, returns, args)
                 args[1], args[2] =
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
   
                 if not _G.wallbang then
                    returns = table.pack(self.Raycast(self, unpack(args)))
                 else
                    local FilterDescendantsInstances = args[3].FilterDescendantsInstances
                    local FilterType = Enum.RaycastFilterType.Whitelist
                    local IgnoreWater = args[3].IgnoreWater
                    local CollisionGroup = args[3].CollisionGroup
                    args[3] =
                    RaycastParams.new(
                    {
                       FilterDescendantsInstances = FilterDescendantsInstances,
                       FilterType = FilterType,
                       IgnoreWater = IgnoreWater,
                       CollisionGroup = CollisionGroup
                    }
                    )
                    returns = table.pack(self.Raycast(self, unpack(args)))
                 end
   
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              }
           }
   
           -- the actual script
           local getnamecallmethod = getnamecallmethod or getnamecall_method
           local newcclosure = newcclosure or hide_me or function(func)
           return func
        end
   
        local checkcaller = checkcaller or is_protosmasher_caller or Cer.isCerus
   
        uis = game:GetService("UserInputService")
        local player = game.Players.LocalPlayer
        mouse = player:GetMouse()
   
        local mt = getrawmetatable(game)
   
        local mt_index, mt_namecall = mt.__index, mt.__namecall
   
        if setreadonly then
           setreadonly(mt, false)
        elseif make_writeable then
           make_writeable(mt, true)
        end
   
        function IsTeamMate(Player1, Player2)
           return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and
           Player1.TeamColor == Player2.TeamColor)
        end
   
        if not _G.MUTEX then
           _G.MUTEX = true
   
           local aimbot = true
           function mt:__index(index)
              local value = mt_index(self, index)
   
              if not checkcaller() then
                 if aimbot then
                    local table  -- im pretty sure this works like rawget for properties
                    for index, value in pairs(_G.indexTable) do
                       if self:IsA(index) then
                          table = value
                          break
                       end
                    end
   
                    if table then
                       table = table[index:lower()]
                       if table then
                          if table.Enabled then
                             if _G.closestCharacter then
                                return table.Function(self, value)
                             end
                          end
                       end
                    end
                 end
              end
   
              return value
           end
   
           function mt:__namecall(...)
              local args = {
                 ...
              }
   
              local returns = table.pack(mt_namecall(self, unpack(args)))
   
              if aimbot then
                 local table = _G.namecallTable[getnamecallmethod():lower()]
                 if table then
                    if table.Enabled then
                       if _G.closestCharacter then
                          returns = table.Function(self, returns, args)
                       end
                    end
                 end
              end
   
              return unpack(returns)
           end
   
           uis.InputBegan:Connect(
           function(input, gameProcessed)
              if not gameProcessed and _G.bindEnabled then
                 if input.KeyCode == _G.bind then
                    aimbot = not aimbot
                 end
              end
           end
           )
   
           while wait() do
              pcall(
              function()
                 -- because this shit breaks like 24/7
                 _G.closestCharacter, closestDistance = nil, math.huge
                 for _, currentPlayer in ipairs(game.Players:GetPlayers()) do
                    if not table.find(_G.whitelist, currentPlayer.Name) then
                       if currentPlayer ~= game.Players.LocalPlayer then
                          local character = currentPlayer.Character
                          if character then
                             local humanoid = character:FindFirstChildWhichIsA("Humanoid")
                             if humanoid and humanoid.Health > 0 and not IsTeamMate(player, currentPlayer) then
                                if
                                not _G.friendsListIsWhitelisted or
                                (_G.friendsListIsWhitelisted and
                                not currentPlayer:IsFriendsWith(player.UserId))
                                then
                                   local vector, onScreen =
                                   workspace.CurrentCamera:WorldToScreenPoint(
                                   character[_G.targetPart].Position
                                   )
                                   if onScreen then
                                      local magnitude =
                                      (Vector2.new(mouse.X, mouse.Y) - Vector2.new(vector.X, vector.Y)).magnitude
                                      if magnitude < closestDistance then
                                         if magnitude <= _G.FOV then
                                            _G.closestCharacter, closestDistance = character, magnitude
                                         end
                                      end
                                   end
                                end
                             end
                          end
                       end
                    end
                 end
              end
              )
           end
        end
     else
        -- settings, if you want to change some settings just re-execute.
        _G.whitelist = {
           "ItsIofty"
        }
        _G.friendsListIsWhitelisted = true -- change if you don't want to lock onto your friends
        _G.targetPart = "Head"
        _G.bindEnabled = false
        _G.bind = Enum.KeyCode.E -- use the keycode reference: https://developer.roblox.com/en-us/api-reference/enum/KeyCode, this keydisables aimbot
   
        _G.FOV = 0
   
        -- This is primarily useful in first person shooters, note, wallbang will not work when you disable this.
        local RAYCAST_ENABLED = true
        -- -- This is rarely useful, however in some cases you might want it.
        local MOUSE_TARGET_ENABLED = false
        -- This is useful for most third person shooters.  It will function very well if you're having bugs, switch to mouse position.
        local MOUSE_HIT_ENABLED = false
        -- If you want to spoof the mouse's x and y coordinated on the screen.  usually if it's a 3rd person shooter it will use this or mouse hit.
        local MOUSE_POSITION_ENABLED = false
        -- I'm not sure what you're going to use this for, but it works I guess
        local MOUSE_ORIGIN_ENABLED = false
   
        _G.indexTable = {
           -- mainly for scripters, but basically these are mouse properties that you might want to enable/disable if it's bugging out.
           ["Mouse"] = {
              ["target"] = {
                 Function = function(self, value)
                 return _G.closestCharacter[_G.targetPart]
                 end,
                 Enabled = MOUSE_TARGET_ENABLED
              },
              ["hit"] = {
                 Function = function(self, value)
                 return _G.closestCharacter[_G.targetPart].CFrame
                 end,
                 Enabled = MOUSE_HIT_ENABLED
              },
              ["origin"] = {
                 Function = function(self, value)
                 return CFrame.new(value.Position, _G.closestCharacter[_G.targetPart].Position)
                 end,
                 Enabled = MOUSE_ORIGIN_ENABLED
              },
              ["x"] = {
                 Function = function(self, value)
                 return uis:GetMouseLocation().X
                 end,
                 Enabled = MOUSE_POSITION_ENABLED
              },
              ["y"] = {
                 Function = function(self, value)
                 return uis:GetMouseLocation().Y
                 end,
                 Enabled = MOUSE_POSITION_ENABLED
              },
              ["unitray"] = {
                 Function = function(self, value)
                 return Ray.new(
                 self.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position - self.Origin.Position).Unit
                 )
                 end,
                 Enabled = RAYCAST_ENABLED
              }
           },
           ["Humanoid"] = {
              ["targetpoint"] = {
                 Function = function(self, value)
                 return _G.closestCharacter[_G.targetPart].Position
                 end,
                 Enabled = MOUSE_HIT_ENABLED
              }
           }
        }
   
        _G.namecallTable = {
           ["getmouselocation"] = {
              Function = function(self, returns, args)
              local vector =
              workspace.CurrentCamera.WorldToViewportPoint(
              workspace.CurrentCamera,
              _G.closestCharacter[_G.targetPart].Position
              )
              returns[1] = Vector2.new(vector.X, vector.Y)
              return returns
              end,
              Enabled = MOUSE_POSITION_ENABLED
           },
           ["findpartonraywithignorelist"] = {
              Function = function(self, returns, args)
              args[1] =
              Ray.new(
              mouse.Origin.Position,
              (_G.closestCharacter[_G.targetPart].Position +
              Vector3.new(
              0,
              (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
              0
              ) -
              mouse.Origin.Position).unit * 500
              )
              if not _G.wallbang then
                 returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
              else
                 args[2] = {}
                 for _, player in ipairs(game.Players:GetPlayers()) do
                    if player.Character then
                       table.insert(args[2], player.Character)
                    end
                 end
                 returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
              end
              return returns
              end,
              Enabled = RAYCAST_ENABLED
           },
           ["findpartonray"] = {
              Function = function(self, returns, args)
              args[1] =
              Ray.new(
              mouse.Origin.Position,
              (_G.closestCharacter[_G.targetPart].Position +
              Vector3.new(
              0,
              (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
              0
              ) -
              mouse.Origin.Position).unit * 500
              )
              if not args[2] then
                 args[2] = {}
              end
              if not _G.wallbang then
                 returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
              else
                 args[2] = {}
                 for _, player in ipairs(game.Players:GetPlayers()) do
                    if player.Character then
                       table.insert(args[2], player.Character)
                    end
                 end
                 returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
              end
              return returns
              end,
              Enabled = RAYCAST_ENABLED
           },
           ["findpartonraywithwhitelist"] = {
              Function = function(self, returns, args)
              args[1] =
              Ray.new(
              mouse.Origin.Position,
              (_G.closestCharacter[_G.targetPart].Position +
              Vector3.new(
              0,
              (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
              0
              ) -
              mouse.Origin.Position).unit * 500
              )
              if not _G.wallbang then
                 returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
              else
                 for _, player in ipairs(game.Players:GetPlayers()) do
                    if player.Character then
                       table.insert(args[2], player.Character)
                    end
                 end
                 returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
              end
   
              return returns
              end,
              Enabled = RAYCAST_ENABLED
           },
           ["raycast"] = {
              Function = function(self, returns, args)
              args[1], args[2] =
              mouse.Origin.Position,
              (_G.closestCharacter[_G.targetPart].Position +
              Vector3.new(
              0,
              (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
              0
              ) -
              mouse.Origin.Position).unit * 500
   
              if not _G.wallbang then
                 returns = table.pack(self.Raycast(self, unpack(args)))
              else
                 local FilterDescendantsInstances = args[3].FilterDescendantsInstances
                 local FilterType = Enum.RaycastFilterType.Whitelist
                 local IgnoreWater = args[3].IgnoreWater
                 local CollisionGroup = args[3].CollisionGroup
                 args[3] =
                 RaycastParams.new(
                 {
                    FilterDescendantsInstances = FilterDescendantsInstances,
                    FilterType = FilterType,
                    IgnoreWater = IgnoreWater,
                    CollisionGroup = CollisionGroup
                 }
                 )
                 returns = table.pack(self.Raycast(self, unpack(args)))
              end
   
              return returns
              end,
              Enabled = RAYCAST_ENABLED
           }
        }
   
        -- the actual script
        local getnamecallmethod = getnamecallmethod or getnamecall_method
        local newcclosure = newcclosure or hide_me or function(func)
        return func
     end
   
     local checkcaller = checkcaller or is_protosmasher_caller or Cer.isCerus
   
     uis = game:GetService("UserInputService")
     local player = game.Players.LocalPlayer
     mouse = player:GetMouse()
   
     local mt = getrawmetatable(game)
   
     local mt_index, mt_namecall = mt.__index, mt.__namecall
   
     if setreadonly then
        setreadonly(mt, false)
     elseif make_writeable then
        make_writeable(mt, true)
     end
   
     function IsTeamMate(Player1, Player2)
        return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and
        Player1.TeamColor == Player2.TeamColor)
     end
   
     if not _G.MUTEX then
        _G.MUTEX = true
   
        local aimbot = true
        function mt:__index(index)
           local value = mt_index(self, index)
   
           if not checkcaller() then
              if aimbot then
                 local table  -- im pretty sure this works like rawget for properties
                 for index, value in pairs(_G.indexTable) do
                    if self:IsA(index) then
                       table = value
                       break
                    end
                 end
   
                 if table then
                    table = table[index:lower()]
                    if table then
                       if table.Enabled then
                          if _G.closestCharacter then
                             return table.Function(self, value)
                          end
                       end
                    end
                 end
              end
           end
   
           return value
        end
   
        function mt:__namecall(...)
           local args = {
              ...
           }
   
           local returns = table.pack(mt_namecall(self, unpack(args)))
   
           if aimbot then
              local table = _G.namecallTable[getnamecallmethod():lower()]
              if table then
                 if table.Enabled then
                    if _G.closestCharacter then
                       returns = table.Function(self, returns, args)
                    end
                 end
              end
           end
   
           return unpack(returns)
        end
   
        uis.InputBegan:Connect(
        function(input, gameProcessed)
           if not gameProcessed and _G.bindEnabled then
              if input.KeyCode == _G.bind then
                 aimbot = not aimbot
              end
           end
        end
        )
   
        while wait() do
           pcall(
           function()
              -- because this shit breaks like 24/7
              _G.closestCharacter, closestDistance = nil, math.huge
              for _, currentPlayer in ipairs(game.Players:GetPlayers()) do
                 if not table.find(_G.whitelist, currentPlayer.Name) then
                    if currentPlayer ~= game.Players.LocalPlayer then
                       local character = currentPlayer.Character
                       if character then
                          local humanoid = character:FindFirstChildWhichIsA("Humanoid")
                          if humanoid and humanoid.Health > 0 and not IsTeamMate(player, currentPlayer) then
                             if
                             not _G.friendsListIsWhitelisted or
                             (_G.friendsListIsWhitelisted and
                             not currentPlayer:IsFriendsWith(player.UserId))
                             then
                                local vector, onScreen =
                                workspace.CurrentCamera:WorldToScreenPoint(
                                character[_G.targetPart].Position
                                )
                                if onScreen then
                                   local magnitude =
                                   (Vector2.new(mouse.X, mouse.Y) - Vector2.new(vector.X, vector.Y)).magnitude
                                   if magnitude < closestDistance then
                                      if magnitude <= _G.FOV then
                                         _G.closestCharacter, closestDistance = character, magnitude
                                      end
                                   end
                                end
                             end
                          end
                       end
                    end
                 end
              end
           end
           )
        end
     end
   end
   end)

   HomePage:AddButton("No Recoil", function()
    game.Players.LocalPlayer.Backpack.WalkAnimation.recoil.antirecoil:Destroy()
   end)
   
   
   
   --Self
   SelfPage:AddToggle("Walkspeed", function(State)
       if state == true then
           while wait(1) do
              Speed = 1 -- 1 is pretty much good but you do you :D
   
              _G.Speed = true -- Toggle Speed
   
              You = game.Players.LocalPlayer.Name
              UIS = game:GetService("UserInputService")
   
              while _G.Speed do
                 if UIS:IsKeyDown(Enum.KeyCode.W) then
                    game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,-Speed)
                    end;
                    if UIS:IsKeyDown(Enum.KeyCode.A) then
                       game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(-Speed,0,0)
                       end;
                       if UIS:IsKeyDown(Enum.KeyCode.S) then
                          game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,Speed)
                          end;
                          if UIS:IsKeyDown(Enum.KeyCode.D) then
                             game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(Speed,0,0)
                             end;
                             wait()
                          end
                       end
                    else
                       while wait(1) do
                          Speed = 1 -- 1 is pretty much good but you do you :D
   
                          _G.Speed = false -- Toggle Speed
   
                          You = game.Players.LocalPlayer.Name
                          UIS = game:GetService("UserInputService")
   
                          while _G.Speed do
                             if UIS:IsKeyDown(Enum.KeyCode.W) then
                                game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,-Speed)
                                end;
                                if UIS:IsKeyDown(Enum.KeyCode.A) then
                                   game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(-Speed,0,0)
                                   end;
                                   if UIS:IsKeyDown(Enum.KeyCode.S) then
                                      game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,Speed)
                                      end;
                                      if UIS:IsKeyDown(Enum.KeyCode.D) then
                                         game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(Speed,0,0)
                                         end;
                                         wait()
                                      end
                                   end
                                end
   end)
   
   
   SelfPage:AddButton("Fly", function()
       loadstring(game:HttpGet(('https://pastebin.com/raw/WxmvCLLH'),true))()
   end)
   
   SelfPage:AddButton("Low Gravity", function()
       local p = game.Players.LocalPlayer.Character.HumanoidRootPart
   local yeah_this_is_yeah = Instance.new("BodyForce")
   yeah_this_is_yeah.Parent = p
   yeah_this_is_yeah.Force = Vector3.new(0, 2000, 0)
   end)
   
   
   
   --Visual
   VisualsPage:AddToggle("Box", function(state)
       ESP:BoxESPToggle(state)
   end)
   
   VisualsPage:AddToggle("Tracers", function(state)
       ESP:TracersToggle(state)
   end)
   
   VisualsPage:AddToggle("Names", function(state)
       ESP:NameESPToggle(state)
   end)
   
   VisualsPage:AddToggle("Teamcheck", function(state)
       ESP:TeamcheckToggle(state)
   end)
   
   VisualsPage:AddToggle("Chams", function(state)
       if state == true then
           local color = BrickColor.new(255, 0, 50)
           local transparency = 0
   
           local Players = game:GetService("Players")
           local function _ESP(c)
              repeat wait() until c.PrimaryPart ~= nil
                 for i,p in pairs(c:GetChildren()) do
                    if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                       if p:FindFirstChild("4329138913") then p.shit:Destroy() end
                       local a = Instance.new("BoxHandleAdornment",p)
                       a.Name = "4329138913"
                       a.Size = p.Size
                       a.Color = color
                       a.Transparency = transparency
                       a.AlwaysOnTop = true
                       a.Visible = true
                       a.Adornee = p
                       a.ZIndex = true
   
                    end
                 end
              end
              local function ESP()
                 for i,v in pairs(Players:GetChildren()) do
                    if v ~= game.Players.LocalPlayer then
                       if v.Character then
                          _ESP(v.Character)
                       end
                       v.CharacterAdded:Connect(function(chr)
                       _ESP(chr)
                       end)
                    end
                 end
                 Players.PlayerAdded:Connect(function(player)
                 player.CharacterAdded:Connect(function(chr)
                 _ESP(chr)
                 end)
                 end)
              end
              ESP()
   
   
   
           else
   
   
   
              local color = BrickColor.new(255, 0, 50)
              local transparency = 1
   
              local Players = game:GetService("Players")
              local function _ESP(c)
                 repeat wait() until c.PrimaryPart ~= nil
                    for i,p in pairs(c:GetChildren()) do
                       if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                          if p:FindFirstChild("4329138913") then p.shit:Destroy() end
                          local a = Instance.new("BoxHandleAdornment",p)
                          a.Name = "4329138913"
                          a.Size = p.Size
                          a.Color = color
                          a.Transparency = transparency
                          a.AlwaysOnTop = true
                          a.Visible = true
                          a.Adornee = p
                          a.ZIndex = true
   
                       end
                    end
                 end
                 local function ESP()
                    for i,v in pairs(Players:GetChildren()) do
                       if v ~= game.Players.LocalPlayer then
                          if v.Character then
                             _ESP(v.Character)
                          end
                          v.CharacterAdded:Connect(function(chr)
                          _ESP(chr)
                          end)
                       end
                    end
                    Players.PlayerAdded:Connect(function(player)
                    player.CharacterAdded:Connect(function(chr)
                    _ESP(chr)
                    end)
                    end)
                 end
                 ESP()
              end
   end)

   VisualsPage:AddLabel("Player")

   VisualsPage:AddToggle("Gun Chams", function(state)
    if state == true then
        for i,v in pairs(workspace:GetDescendants()) do
            if v:IsA("LeftHand") or v:IsA("RightHand") or v:IsA("MeshPart") then
            v.Material = "ForceField"
            end
            end
            for i,v in pairs(game:GetDescendants()) do
            if v:IsA("Light") or v:IsA("ParticleEmitter") or v:IsA("Trail") then
            v:Destroy()
            end
            end
    else
        for i,v in pairs(workspace:GetDescendants()) do
            if v:IsA("LeftHand") or v:IsA("RightHand") or v:IsA("MeshPart") then
            v.Material = "SmoothPlastic"
            end
            end
    end
   end)
   
   circle = Drawing.new("Circle")
   
   VisualsPage:AddToggle("View FOV", function(state)
       if state == true then
           circle = Drawing.new("Circle")
           circle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
           circle.Color = Color3.fromRGB(143, 59, 87)
           circle.Thickness = 1.5
           circle.NumSides = 100
           circle.Radius = FOVAmount
           circle.Visible = true
           circle.Filled = false
   
           local RunService = game:GetService("RunService")
           local player = game.Players.LocalPlayer
           local mouse = player:GetMouse()
           local gi=game:GetService('GuiService'):GetGuiInset();
   
           RunService.Heartbeat:Connect(function()
           circle.Position = Vector2.new(mouse.X, mouse.Y+gi.Y)
           end)
        else
           circle = Drawing.new("Circle")
           circle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
           circle.Color = Color3.fromRGB(143, 59, 87)
           circle.Thickness = 0
           circle.NumSides = 100
           circle.Radius = 0
           circle.Visible = false
           circle.Filled = false
   
           local RunService = game:GetService("RunService")
           local player = game.Players.LocalPlayer
           local mouse = player:GetMouse()
           local gi=game:GetService('GuiService'):GetGuiInset();
   
           RunService.Heartbeat:Connect(function()
           circle.Position = Vector2.new(mouse.X, mouse.Y+gi.Y)
           end)
        end
   end)
   
   VisualsPage:AddLabel("Map")
   
   VisualsPage:AddButton("Fullbright", function()
       if not _G.FullBrightExecuted then
   
           _G.FullBrightEnabled = false
   
           _G.NormalLightingSettings = {
              Brightness = game:GetService("Lighting").Brightness,
              ClockTime = game:GetService("Lighting").ClockTime,
              FogEnd = game:GetService("Lighting").FogEnd,
              GlobalShadows = game:GetService("Lighting").GlobalShadows,
              Ambient = game:GetService("Lighting").Ambient
           }
   
           game:GetService("Lighting"):GetPropertyChangedSignal("Brightness"):Connect(function()
           if game:GetService("Lighting").Brightness ~= 1 and game:GetService("Lighting").Brightness ~= _G.NormalLightingSettings.Brightness then
              _G.NormalLightingSettings.Brightness = game:GetService("Lighting").Brightness
              if not _G.FullBrightEnabled then
                 repeat
                    wait()
                 until _G.FullBrightEnabled
              end
              game:GetService("Lighting").Brightness = 1
           end
           end)
   
           game:GetService("Lighting"):GetPropertyChangedSignal("ClockTime"):Connect(function()
           if game:GetService("Lighting").ClockTime ~= 12 and game:GetService("Lighting").ClockTime ~= _G.NormalLightingSettings.ClockTime then
              _G.NormalLightingSettings.ClockTime = game:GetService("Lighting").ClockTime
              if not _G.FullBrightEnabled then
                 repeat
                    wait()
                 until _G.FullBrightEnabled
              end
              game:GetService("Lighting").ClockTime = 12
           end
           end)
   
           game:GetService("Lighting"):GetPropertyChangedSignal("FogEnd"):Connect(function()
           if game:GetService("Lighting").FogEnd ~= 786543 and game:GetService("Lighting").FogEnd ~= _G.NormalLightingSettings.FogEnd then
              _G.NormalLightingSettings.FogEnd = game:GetService("Lighting").FogEnd
              if not _G.FullBrightEnabled then
                 repeat
                    wait()
                 until _G.FullBrightEnabled
              end
              game:GetService("Lighting").FogEnd = 786543
           end
           end)
   
           game:GetService("Lighting"):GetPropertyChangedSignal("GlobalShadows"):Connect(function()
           if game:GetService("Lighting").GlobalShadows ~= false and game:GetService("Lighting").GlobalShadows ~= _G.NormalLightingSettings.GlobalShadows then
              _G.NormalLightingSettings.GlobalShadows = game:GetService("Lighting").GlobalShadows
              if not _G.FullBrightEnabled then
                 repeat
                    wait()
                 until _G.FullBrightEnabled
              end
              game:GetService("Lighting").GlobalShadows = false
           end
           end)
   
           game:GetService("Lighting"):GetPropertyChangedSignal("Ambient"):Connect(function()
           if game:GetService("Lighting").Ambient ~= Color3.fromRGB(178, 178, 178) and game:GetService("Lighting").Ambient ~= _G.NormalLightingSettings.Ambient then
              _G.NormalLightingSettings.Ambient = game:GetService("Lighting").Ambient
              if not _G.FullBrightEnabled then
                 repeat
                    wait()
                 until _G.FullBrightEnabled
              end
              game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
           end
           end)
   
           game:GetService("Lighting").Brightness = 1
           game:GetService("Lighting").ClockTime = 12
           game:GetService("Lighting").FogEnd = 786543
           game:GetService("Lighting").GlobalShadows = false
           game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
   
           local LatestValue = true
           spawn(function()
           repeat
              wait()
           until _G.FullBrightEnabled
           while wait() do
              if _G.FullBrightEnabled ~= LatestValue then
                 if not _G.FullBrightEnabled then
                    game:GetService("Lighting").Brightness = _G.NormalLightingSettings.Brightness
                    game:GetService("Lighting").ClockTime = _G.NormalLightingSettings.ClockTime
                    game:GetService("Lighting").FogEnd = _G.NormalLightingSettings.FogEnd
                    game:GetService("Lighting").GlobalShadows = _G.NormalLightingSettings.GlobalShadows
                    game:GetService("Lighting").Ambient = _G.NormalLightingSettings.Ambient
                 else
                    game:GetService("Lighting").Brightness = 1
                    game:GetService("Lighting").ClockTime = 12
                    game:GetService("Lighting").FogEnd = 786543
                    game:GetService("Lighting").GlobalShadows = false
                    game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
                 end
                 LatestValue = not LatestValue
              end
           end
           end)
        end
   
        _G.FullBrightExecuted = true
        _G.FullBrightEnabled = not _G.FullBrightEnabled
   end)

   
   
   
   
   
   --Misc
   
   
   MiscPage:AddBind("Toggle GUI", Enum.KeyCode.F8, function()
       ShowerLib:OpenClose() -- opens or closes the UI
   end)
   
   MiscPage:AddButton("Destroy GUI", function()
       ShowerLib:Destroy() -- Kills the GUI
   end)
   end





   if game.PlaceId == 2961297129 then
      Loaded = true
      print("FLUX: Game Death Zone.")
          --Made by : https://v3rmillion.net/member.php?action=profile&uid=1591342
       
      local ShowerLib = loadstring(game:HttpGet("https://fluxteam.xyz/scripts/others/ShowerHeadLibrary.lua"))()
      local ESP = loadstring(game:HttpGet"https://raw.githubusercontent.com/dawid-scripts/Helios-Hub/main/Scripts/HeliosESP.lua")()
      local Window = ShowerLib:CreateWindow("F"); --Clicking this will make it rotate.
      local HomePage = Window:Section("Aim")
      local SelfPage = Window:Section("Self")
      local VisualsPage = Window:Section("Visual")
      local MiscPage = Window:Section("Misc")
      ESP:SetESPColor(Color3.fromRGB(0, 166, 255))
      
      
      --Configuration
      --Circle
      local FOVAmount = ""
   
   
      --Load settings
      local LightingModuleDeleted = false
      --Configuration
      
      HomePage:AddSlider("FOV", 100, 400, 10, function(Value)
          FOVAmount = Value -- Value is the value of the slider
      end)
   
      local SelectedBodyPart = "Random"
   
      HomePage:AddDrop(
              "Aimed Part",
              {
                  "Head",
                  "Body",
                  "Random"
              },
              function(value)
                  SelectedBodyPart = value
              end
          )
      
      HomePage:AddToggle("Silent Aim", function(state)
          if state == true then
              -- settings, if you want to change some settings just re-execute.
              _G.whitelist = {
                 "ItsIofty"
              }
              _G.friendsListIsWhitelisted = true -- change if you don't want to lock onto your friends
              _G.targetPart = SelectedBodyPart
              _G.bindEnabled = false
              _G.bind = Enum.KeyCode.E -- use the keycode reference: https://developer.roblox.com/en-us/api-reference/enum/KeyCode, this keydisables aimbot
      
              _G.FOV = FOVAmount
      
              -- This is primarily useful in first person shooters, note, wallbang will not work when you disable this.
              local RAYCAST_ENABLED = true
              -- -- This is rarely useful, however in some cases you might want it.
              local MOUSE_TARGET_ENABLED = false
              -- This is useful for most third person shooters.  It will function very well if you're having bugs, switch to mouse position.
              local MOUSE_HIT_ENABLED = false
              -- If you want to spoof the mouse's x and y coordinated on the screen.  usually if it's a 3rd person shooter it will use this or mouse hit.
              local MOUSE_POSITION_ENABLED = false
              -- I'm not sure what you're going to use this for, but it works I guess
              local MOUSE_ORIGIN_ENABLED = false
      
              _G.indexTable = {
                 -- mainly for scripters, but basically these are mouse properties that you might want to enable/disable if it's bugging out.
                 ["Mouse"] = {
                    ["target"] = {
                       Function = function(self, value)
                       return _G.closestCharacter[_G.targetPart]
                       end,
                       Enabled = MOUSE_TARGET_ENABLED
                    },
                    ["hit"] = {
                       Function = function(self, value)
                       return _G.closestCharacter[_G.targetPart].CFrame
                       end,
                       Enabled = MOUSE_HIT_ENABLED
                    },
                    ["origin"] = {
                       Function = function(self, value)
                       return CFrame.new(value.Position, _G.closestCharacter[_G.targetPart].Position)
                       end,
                       Enabled = MOUSE_ORIGIN_ENABLED
                    },
                    ["x"] = {
                       Function = function(self, value)
                       return uis:GetMouseLocation().X
                       end,
                       Enabled = MOUSE_POSITION_ENABLED
                    },
                    ["y"] = {
                       Function = function(self, value)
                       return uis:GetMouseLocation().Y
                       end,
                       Enabled = MOUSE_POSITION_ENABLED
                    },
                    ["unitray"] = {
                       Function = function(self, value)
                       return Ray.new(
                       self.Origin.Position,
                       (_G.closestCharacter[_G.targetPart].Position - self.Origin.Position).Unit
                       )
                       end,
                       Enabled = RAYCAST_ENABLED
                    }
                 },
                 ["Humanoid"] = {
                    ["targetpoint"] = {
                       Function = function(self, value)
                       return _G.closestCharacter[_G.targetPart].Position
                       end,
                       Enabled = MOUSE_HIT_ENABLED
                    }
                 }
              }
      
              _G.namecallTable = {
                 ["getmouselocation"] = {
                    Function = function(self, returns, args)
                    local vector =
                    workspace.CurrentCamera.WorldToViewportPoint(
                    workspace.CurrentCamera,
                    _G.closestCharacter[_G.targetPart].Position
                    )
                    returns[1] = Vector2.new(vector.X, vector.Y)
                    return returns
                    end,
                    Enabled = MOUSE_POSITION_ENABLED
                 },
                 ["findpartonraywithignorelist"] = {
                    Function = function(self, returns, args)
                    args[1] =
                    Ray.new(
                    mouse.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                    0,
                    (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                    0
                    ) -
                    mouse.Origin.Position).unit * 500
                    )
                    if not _G.wallbang then
                       returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                    else
                       args[2] = {}
                       for _, player in ipairs(game.Players:GetPlayers()) do
                          if player.Character then
                             table.insert(args[2], player.Character)
                          end
                       end
                       returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                    end
                    return returns
                    end,
                    Enabled = RAYCAST_ENABLED
                 },
                 ["findpartonray"] = {
                    Function = function(self, returns, args)
                    args[1] =
                    Ray.new(
                    mouse.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                    0,
                    (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                    0
                    ) -
                    mouse.Origin.Position).unit * 500
                    )
                    if not args[2] then
                       args[2] = {}
                    end
                    if not _G.wallbang then
                       returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                    else
                       args[2] = {}
                       for _, player in ipairs(game.Players:GetPlayers()) do
                          if player.Character then
                             table.insert(args[2], player.Character)
                          end
                       end
                       returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                    end
                    return returns
                    end,
                    Enabled = RAYCAST_ENABLED
                 },
                 ["findpartonraywithwhitelist"] = {
                    Function = function(self, returns, args)
                    args[1] =
                    Ray.new(
                    mouse.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                    0,
                    (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                    0
                    ) -
                    mouse.Origin.Position).unit * 500
                    )
                    if not _G.wallbang then
                       returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                    else
                       for _, player in ipairs(game.Players:GetPlayers()) do
                          if player.Character then
                             table.insert(args[2], player.Character)
                          end
                       end
                       returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                    end
      
                    return returns
                    end,
                    Enabled = RAYCAST_ENABLED
                 },
                 ["raycast"] = {
                    Function = function(self, returns, args)
                    args[1], args[2] =
                    mouse.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                    0,
                    (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                    0
                    ) -
                    mouse.Origin.Position).unit * 500
      
                    if not _G.wallbang then
                       returns = table.pack(self.Raycast(self, unpack(args)))
                    else
                       local FilterDescendantsInstances = args[3].FilterDescendantsInstances
                       local FilterType = Enum.RaycastFilterType.Whitelist
                       local IgnoreWater = args[3].IgnoreWater
                       local CollisionGroup = args[3].CollisionGroup
                       args[3] =
                       RaycastParams.new(
                       {
                          FilterDescendantsInstances = FilterDescendantsInstances,
                          FilterType = FilterType,
                          IgnoreWater = IgnoreWater,
                          CollisionGroup = CollisionGroup
                       }
                       )
                       returns = table.pack(self.Raycast(self, unpack(args)))
                    end
      
                    return returns
                    end,
                    Enabled = RAYCAST_ENABLED
                 }
              }
      
              -- the actual script
              local getnamecallmethod = getnamecallmethod or getnamecall_method
              local newcclosure = newcclosure or hide_me or function(func)
              return func
           end
      
           local checkcaller = checkcaller or is_protosmasher_caller or Cer.isCerus
      
           uis = game:GetService("UserInputService")
           local player = game.Players.LocalPlayer
           mouse = player:GetMouse()
      
           local mt = getrawmetatable(game)
      
           local mt_index, mt_namecall = mt.__index, mt.__namecall
      
           if setreadonly then
              setreadonly(mt, false)
           elseif make_writeable then
              make_writeable(mt, true)
           end
      
           function IsTeamMate(Player1, Player2)
              return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and
              Player1.TeamColor == Player2.TeamColor)
           end
      
           if not _G.MUTEX then
              _G.MUTEX = true
      
              local aimbot = true
              function mt:__index(index)
                 local value = mt_index(self, index)
      
                 if not checkcaller() then
                    if aimbot then
                       local table  -- im pretty sure this works like rawget for properties
                       for index, value in pairs(_G.indexTable) do
                          if self:IsA(index) then
                             table = value
                             break
                          end
                       end
      
                       if table then
                          table = table[index:lower()]
                          if table then
                             if table.Enabled then
                                if _G.closestCharacter then
                                   return table.Function(self, value)
                                end
                             end
                          end
                       end
                    end
                 end
      
                 return value
              end
      
              function mt:__namecall(...)
                 local args = {
                    ...
                 }
      
                 local returns = table.pack(mt_namecall(self, unpack(args)))
      
                 if aimbot then
                    local table = _G.namecallTable[getnamecallmethod():lower()]
                    if table then
                       if table.Enabled then
                          if _G.closestCharacter then
                             returns = table.Function(self, returns, args)
                          end
                       end
                    end
                 end
      
                 return unpack(returns)
              end
      
              uis.InputBegan:Connect(
              function(input, gameProcessed)
                 if not gameProcessed and _G.bindEnabled then
                    if input.KeyCode == _G.bind then
                       aimbot = not aimbot
                    end
                 end
              end
              )
      
              while wait() do
                 pcall(
                 function()
                    -- because this shit breaks like 24/7
                    _G.closestCharacter, closestDistance = nil, math.huge
                    for _, currentPlayer in ipairs(game.Players:GetPlayers()) do
                       if not table.find(_G.whitelist, currentPlayer.Name) then
                          if currentPlayer ~= game.Players.LocalPlayer then
                             local character = currentPlayer.Character
                             if character then
                                local humanoid = character:FindFirstChildWhichIsA("Humanoid")
                                if humanoid and humanoid.Health > 0 and not IsTeamMate(player, currentPlayer) then
                                   if
                                   not _G.friendsListIsWhitelisted or
                                   (_G.friendsListIsWhitelisted and
                                   not currentPlayer:IsFriendsWith(player.UserId))
                                   then
                                      local vector, onScreen =
                                      workspace.CurrentCamera:WorldToScreenPoint(
                                      character[_G.targetPart].Position
                                      )
                                      if onScreen then
                                         local magnitude =
                                         (Vector2.new(mouse.X, mouse.Y) - Vector2.new(vector.X, vector.Y)).magnitude
                                         if magnitude < closestDistance then
                                            if magnitude <= _G.FOV then
                                               _G.closestCharacter, closestDistance = character, magnitude
                                            end
                                         end
                                      end
                                   end
                                end
                             end
                          end
                       end
                    end
                 end
                 )
              end
           end
        else
           -- settings, if you want to change some settings just re-execute.
           _G.whitelist = {
              "ItsIofty"
           }
           _G.friendsListIsWhitelisted = true -- change if you don't want to lock onto your friends
           _G.targetPart = "Head"
           _G.bindEnabled = false
           _G.bind = Enum.KeyCode.E -- use the keycode reference: https://developer.roblox.com/en-us/api-reference/enum/KeyCode, this keydisables aimbot
      
           _G.FOV = 0
      
           -- This is primarily useful in first person shooters, note, wallbang will not work when you disable this.
           local RAYCAST_ENABLED = true
           -- -- This is rarely useful, however in some cases you might want it.
           local MOUSE_TARGET_ENABLED = false
           -- This is useful for most third person shooters.  It will function very well if you're having bugs, switch to mouse position.
           local MOUSE_HIT_ENABLED = false
           -- If you want to spoof the mouse's x and y coordinated on the screen.  usually if it's a 3rd person shooter it will use this or mouse hit.
           local MOUSE_POSITION_ENABLED = false
           -- I'm not sure what you're going to use this for, but it works I guess
           local MOUSE_ORIGIN_ENABLED = false
      
           _G.indexTable = {
              -- mainly for scripters, but basically these are mouse properties that you might want to enable/disable if it's bugging out.
              ["Mouse"] = {
                 ["target"] = {
                    Function = function(self, value)
                    return _G.closestCharacter[_G.targetPart]
                    end,
                    Enabled = MOUSE_TARGET_ENABLED
                 },
                 ["hit"] = {
                    Function = function(self, value)
                    return _G.closestCharacter[_G.targetPart].CFrame
                    end,
                    Enabled = MOUSE_HIT_ENABLED
                 },
                 ["origin"] = {
                    Function = function(self, value)
                    return CFrame.new(value.Position, _G.closestCharacter[_G.targetPart].Position)
                    end,
                    Enabled = MOUSE_ORIGIN_ENABLED
                 },
                 ["x"] = {
                    Function = function(self, value)
                    return uis:GetMouseLocation().X
                    end,
                    Enabled = MOUSE_POSITION_ENABLED
                 },
                 ["y"] = {
                    Function = function(self, value)
                    return uis:GetMouseLocation().Y
                    end,
                    Enabled = MOUSE_POSITION_ENABLED
                 },
                 ["unitray"] = {
                    Function = function(self, value)
                    return Ray.new(
                    self.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position - self.Origin.Position).Unit
                    )
                    end,
                    Enabled = RAYCAST_ENABLED
                 }
              },
              ["Humanoid"] = {
                 ["targetpoint"] = {
                    Function = function(self, value)
                    return _G.closestCharacter[_G.targetPart].Position
                    end,
                    Enabled = MOUSE_HIT_ENABLED
                 }
              }
           }
      
           _G.namecallTable = {
              ["getmouselocation"] = {
                 Function = function(self, returns, args)
                 local vector =
                 workspace.CurrentCamera.WorldToViewportPoint(
                 workspace.CurrentCamera,
                 _G.closestCharacter[_G.targetPart].Position
                 )
                 returns[1] = Vector2.new(vector.X, vector.Y)
                 return returns
                 end,
                 Enabled = MOUSE_POSITION_ENABLED
              },
              ["findpartonraywithignorelist"] = {
                 Function = function(self, returns, args)
                 args[1] =
                 Ray.new(
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
                 )
                 if not _G.wallbang then
                    returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                 else
                    args[2] = {}
                    for _, player in ipairs(game.Players:GetPlayers()) do
                       if player.Character then
                          table.insert(args[2], player.Character)
                       end
                    end
                    returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                 end
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              },
              ["findpartonray"] = {
                 Function = function(self, returns, args)
                 args[1] =
                 Ray.new(
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
                 )
                 if not args[2] then
                    args[2] = {}
                 end
                 if not _G.wallbang then
                    returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                 else
                    args[2] = {}
                    for _, player in ipairs(game.Players:GetPlayers()) do
                       if player.Character then
                          table.insert(args[2], player.Character)
                       end
                    end
                    returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                 end
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              },
              ["findpartonraywithwhitelist"] = {
                 Function = function(self, returns, args)
                 args[1] =
                 Ray.new(
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
                 )
                 if not _G.wallbang then
                    returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                 else
                    for _, player in ipairs(game.Players:GetPlayers()) do
                       if player.Character then
                          table.insert(args[2], player.Character)
                       end
                    end
                    returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                 end
      
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              },
              ["raycast"] = {
                 Function = function(self, returns, args)
                 args[1], args[2] =
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
      
                 if not _G.wallbang then
                    returns = table.pack(self.Raycast(self, unpack(args)))
                 else
                    local FilterDescendantsInstances = args[3].FilterDescendantsInstances
                    local FilterType = Enum.RaycastFilterType.Whitelist
                    local IgnoreWater = args[3].IgnoreWater
                    local CollisionGroup = args[3].CollisionGroup
                    args[3] =
                    RaycastParams.new(
                    {
                       FilterDescendantsInstances = FilterDescendantsInstances,
                       FilterType = FilterType,
                       IgnoreWater = IgnoreWater,
                       CollisionGroup = CollisionGroup
                    }
                    )
                    returns = table.pack(self.Raycast(self, unpack(args)))
                 end
      
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              }
           }
      
           -- the actual script
           local getnamecallmethod = getnamecallmethod or getnamecall_method
           local newcclosure = newcclosure or hide_me or function(func)
           return func
        end
      
        local checkcaller = checkcaller or is_protosmasher_caller or Cer.isCerus
      
        uis = game:GetService("UserInputService")
        local player = game.Players.LocalPlayer
        mouse = player:GetMouse()
      
        local mt = getrawmetatable(game)
      
        local mt_index, mt_namecall = mt.__index, mt.__namecall
      
        if setreadonly then
           setreadonly(mt, false)
        elseif make_writeable then
           make_writeable(mt, true)
        end
      
        function IsTeamMate(Player1, Player2)
           return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and
           Player1.TeamColor == Player2.TeamColor)
        end
      
        if not _G.MUTEX then
           _G.MUTEX = true
      
           local aimbot = true
           function mt:__index(index)
              local value = mt_index(self, index)
      
              if not checkcaller() then
                 if aimbot then
                    local table  -- im pretty sure this works like rawget for properties
                    for index, value in pairs(_G.indexTable) do
                       if self:IsA(index) then
                          table = value
                          break
                       end
                    end
      
                    if table then
                       table = table[index:lower()]
                       if table then
                          if table.Enabled then
                             if _G.closestCharacter then
                                return table.Function(self, value)
                             end
                          end
                       end
                    end
                 end
              end
      
              return value
           end
      
           function mt:__namecall(...)
              local args = {
                 ...
              }
      
              local returns = table.pack(mt_namecall(self, unpack(args)))
      
              if aimbot then
                 local table = _G.namecallTable[getnamecallmethod():lower()]
                 if table then
                    if table.Enabled then
                       if _G.closestCharacter then
                          returns = table.Function(self, returns, args)
                       end
                    end
                 end
              end
      
              return unpack(returns)
           end
      
           uis.InputBegan:Connect(
           function(input, gameProcessed)
              if not gameProcessed and _G.bindEnabled then
                 if input.KeyCode == _G.bind then
                    aimbot = not aimbot
                 end
              end
           end
           )
      
           while wait() do
              pcall(
              function()
                 -- because this shit breaks like 24/7
                 _G.closestCharacter, closestDistance = nil, math.huge
                 for _, currentPlayer in ipairs(game.Players:GetPlayers()) do
                    if not table.find(_G.whitelist, currentPlayer.Name) then
                       if currentPlayer ~= game.Players.LocalPlayer then
                          local character = currentPlayer.Character
                          if character then
                             local humanoid = character:FindFirstChildWhichIsA("Humanoid")
                             if humanoid and humanoid.Health > 0 and not IsTeamMate(player, currentPlayer) then
                                if
                                not _G.friendsListIsWhitelisted or
                                (_G.friendsListIsWhitelisted and
                                not currentPlayer:IsFriendsWith(player.UserId))
                                then
                                   local vector, onScreen =
                                   workspace.CurrentCamera:WorldToScreenPoint(
                                   character[_G.targetPart].Position
                                   )
                                   if onScreen then
                                      local magnitude =
                                      (Vector2.new(mouse.X, mouse.Y) - Vector2.new(vector.X, vector.Y)).magnitude
                                      if magnitude < closestDistance then
                                         if magnitude <= _G.FOV then
                                            _G.closestCharacter, closestDistance = character, magnitude
                                         end
                                      end
                                   end
                                end
                             end
                          end
                       end
                    end
                 end
              end
              )
           end
        end
      end
      end)
   
      HomePage:AddButton("No Recoil", function()
       game.Players.LocalPlayer.Backpack.WalkAnimation.recoil.antirecoil:Destroy()
      end)
      
      
      
      --Self
      SelfPage:AddToggle("Walkspeed", function(State)
          if state == true then
              while wait(1) do
                 Speed = 1 -- 1 is pretty much good but you do you :D
      
                 _G.Speed = true -- Toggle Speed
      
                 You = game.Players.LocalPlayer.Name
                 UIS = game:GetService("UserInputService")
      
                 while _G.Speed do
                    if UIS:IsKeyDown(Enum.KeyCode.W) then
                       game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,-Speed)
                       end;
                       if UIS:IsKeyDown(Enum.KeyCode.A) then
                          game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(-Speed,0,0)
                          end;
                          if UIS:IsKeyDown(Enum.KeyCode.S) then
                             game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,Speed)
                             end;
                             if UIS:IsKeyDown(Enum.KeyCode.D) then
                                game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(Speed,0,0)
                                end;
                                wait()
                             end
                          end
                       else
                          while wait(1) do
                             Speed = 1 -- 1 is pretty much good but you do you :D
      
                             _G.Speed = false -- Toggle Speed
      
                             You = game.Players.LocalPlayer.Name
                             UIS = game:GetService("UserInputService")
      
                             while _G.Speed do
                                if UIS:IsKeyDown(Enum.KeyCode.W) then
                                   game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,-Speed)
                                   end;
                                   if UIS:IsKeyDown(Enum.KeyCode.A) then
                                      game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(-Speed,0,0)
                                      end;
                                      if UIS:IsKeyDown(Enum.KeyCode.S) then
                                         game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,Speed)
                                         end;
                                         if UIS:IsKeyDown(Enum.KeyCode.D) then
                                            game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(Speed,0,0)
                                            end;
                                            wait()
                                         end
                                      end
                                   end
      end)
      
      
      SelfPage:AddButton("Fly", function()
          loadstring(game:HttpGet(('https://pastebin.com/raw/WxmvCLLH'),true))()
      end)
      
      SelfPage:AddButton("Low Gravity", function()
          local p = game.Players.LocalPlayer.Character.HumanoidRootPart
      local yeah_this_is_yeah = Instance.new("BodyForce")
      yeah_this_is_yeah.Parent = p
      yeah_this_is_yeah.Force = Vector3.new(0, 2000, 0)
      end)
      
      
      
      --Visual
      VisualsPage:AddToggle("Box", function(state)
          ESP:BoxESPToggle(state)
      end)
      
      VisualsPage:AddToggle("Tracers", function(state)
          ESP:TracersToggle(state)
      end)
      
      VisualsPage:AddToggle("Names", function(state)
          ESP:NameESPToggle(state)
      end)
      
      VisualsPage:AddToggle("Teamcheck", function(state)
          ESP:TeamcheckToggle(state)
      end)
      
      VisualsPage:AddToggle("Chams", function(state)
          if state == true then
              local color = BrickColor.new(255, 0, 50)
              local transparency = 0
      
              local Players = game:GetService("Players")
              local function _ESP(c)
                 repeat wait() until c.PrimaryPart ~= nil
                    for i,p in pairs(c:GetChildren()) do
                       if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                          if p:FindFirstChild("4329138913") then p.shit:Destroy() end
                          local a = Instance.new("BoxHandleAdornment",p)
                          a.Name = "4329138913"
                          a.Size = p.Size
                          a.Color = color
                          a.Transparency = transparency
                          a.AlwaysOnTop = true
                          a.Visible = true
                          a.Adornee = p
                          a.ZIndex = true
      
                       end
                    end
                 end
                 local function ESP()
                    for i,v in pairs(Players:GetChildren()) do
                       if v ~= game.Players.LocalPlayer then
                          if v.Character then
                             _ESP(v.Character)
                          end
                          v.CharacterAdded:Connect(function(chr)
                          _ESP(chr)
                          end)
                       end
                    end
                    Players.PlayerAdded:Connect(function(player)
                    player.CharacterAdded:Connect(function(chr)
                    _ESP(chr)
                    end)
                    end)
                 end
                 ESP()
      
      
      
              else
      
      
      
                 local color = BrickColor.new(255, 0, 50)
                 local transparency = 1
      
                 local Players = game:GetService("Players")
                 local function _ESP(c)
                    repeat wait() until c.PrimaryPart ~= nil
                       for i,p in pairs(c:GetChildren()) do
                          if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                             if p:FindFirstChild("4329138913") then p.shit:Destroy() end
                             local a = Instance.new("BoxHandleAdornment",p)
                             a.Name = "4329138913"
                             a.Size = p.Size
                             a.Color = color
                             a.Transparency = transparency
                             a.AlwaysOnTop = true
                             a.Visible = true
                             a.Adornee = p
                             a.ZIndex = true
      
                          end
                       end
                    end
                    local function ESP()
                       for i,v in pairs(Players:GetChildren()) do
                          if v ~= game.Players.LocalPlayer then
                             if v.Character then
                                _ESP(v.Character)
                             end
                             v.CharacterAdded:Connect(function(chr)
                             _ESP(chr)
                             end)
                          end
                       end
                       Players.PlayerAdded:Connect(function(player)
                       player.CharacterAdded:Connect(function(chr)
                       _ESP(chr)
                       end)
                       end)
                    end
                    ESP()
                 end
      end)
   
      VisualsPage:AddLabel("Player")
   
      VisualsPage:AddToggle("Gun Chams", function(state)
       if state == true then
           for i,v in pairs(workspace:GetDescendants()) do
               if v:IsA("LeftHand") or v:IsA("RightHand") or v:IsA("MeshPart") then
               v.Material = "ForceField"
               end
               end
               for i,v in pairs(game:GetDescendants()) do
               if v:IsA("Light") or v:IsA("ParticleEmitter") or v:IsA("Trail") then
               v:Destroy()
               end
               end
       else
           for i,v in pairs(workspace:GetDescendants()) do
               if v:IsA("LeftHand") or v:IsA("RightHand") or v:IsA("MeshPart") then
               v.Material = "SmoothPlastic"
               end
               end
       end
      end)
      
      circle = Drawing.new("Circle")
      
      VisualsPage:AddToggle("View FOV", function(state)
          if state == true then
              circle = Drawing.new("Circle")
              circle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
              circle.Color = Color3.fromRGB(143, 59, 87)
              circle.Thickness = 1.5
              circle.NumSides = 100
              circle.Radius = FOVAmount
              circle.Visible = true
              circle.Filled = false
      
              local RunService = game:GetService("RunService")
              local player = game.Players.LocalPlayer
              local mouse = player:GetMouse()
              local gi=game:GetService('GuiService'):GetGuiInset();
      
              RunService.Heartbeat:Connect(function()
              circle.Position = Vector2.new(mouse.X, mouse.Y+gi.Y)
              end)
           else
              circle = Drawing.new("Circle")
              circle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
              circle.Color = Color3.fromRGB(143, 59, 87)
              circle.Thickness = 0
              circle.NumSides = 100
              circle.Radius = 0
              circle.Visible = false
              circle.Filled = false
      
              local RunService = game:GetService("RunService")
              local player = game.Players.LocalPlayer
              local mouse = player:GetMouse()
              local gi=game:GetService('GuiService'):GetGuiInset();
      
              RunService.Heartbeat:Connect(function()
              circle.Position = Vector2.new(mouse.X, mouse.Y+gi.Y)
              end)
           end
      end)
      
      VisualsPage:AddLabel("Map")
      
      VisualsPage:AddButton("Fullbright", function()
          if not _G.FullBrightExecuted then
      
              _G.FullBrightEnabled = false
      
              _G.NormalLightingSettings = {
                 Brightness = game:GetService("Lighting").Brightness,
                 ClockTime = game:GetService("Lighting").ClockTime,
                 FogEnd = game:GetService("Lighting").FogEnd,
                 GlobalShadows = game:GetService("Lighting").GlobalShadows,
                 Ambient = game:GetService("Lighting").Ambient
              }
      
              game:GetService("Lighting"):GetPropertyChangedSignal("Brightness"):Connect(function()
              if game:GetService("Lighting").Brightness ~= 1 and game:GetService("Lighting").Brightness ~= _G.NormalLightingSettings.Brightness then
                 _G.NormalLightingSettings.Brightness = game:GetService("Lighting").Brightness
                 if not _G.FullBrightEnabled then
                    repeat
                       wait()
                    until _G.FullBrightEnabled
                 end
                 game:GetService("Lighting").Brightness = 1
              end
              end)
      
              game:GetService("Lighting"):GetPropertyChangedSignal("ClockTime"):Connect(function()
              if game:GetService("Lighting").ClockTime ~= 12 and game:GetService("Lighting").ClockTime ~= _G.NormalLightingSettings.ClockTime then
                 _G.NormalLightingSettings.ClockTime = game:GetService("Lighting").ClockTime
                 if not _G.FullBrightEnabled then
                    repeat
                       wait()
                    until _G.FullBrightEnabled
                 end
                 game:GetService("Lighting").ClockTime = 12
              end
              end)
      
              game:GetService("Lighting"):GetPropertyChangedSignal("FogEnd"):Connect(function()
              if game:GetService("Lighting").FogEnd ~= 786543 and game:GetService("Lighting").FogEnd ~= _G.NormalLightingSettings.FogEnd then
                 _G.NormalLightingSettings.FogEnd = game:GetService("Lighting").FogEnd
                 if not _G.FullBrightEnabled then
                    repeat
                       wait()
                    until _G.FullBrightEnabled
                 end
                 game:GetService("Lighting").FogEnd = 786543
              end
              end)
      
              game:GetService("Lighting"):GetPropertyChangedSignal("GlobalShadows"):Connect(function()
              if game:GetService("Lighting").GlobalShadows ~= false and game:GetService("Lighting").GlobalShadows ~= _G.NormalLightingSettings.GlobalShadows then
                 _G.NormalLightingSettings.GlobalShadows = game:GetService("Lighting").GlobalShadows
                 if not _G.FullBrightEnabled then
                    repeat
                       wait()
                    until _G.FullBrightEnabled
                 end
                 game:GetService("Lighting").GlobalShadows = false
              end
              end)
      
              game:GetService("Lighting"):GetPropertyChangedSignal("Ambient"):Connect(function()
              if game:GetService("Lighting").Ambient ~= Color3.fromRGB(178, 178, 178) and game:GetService("Lighting").Ambient ~= _G.NormalLightingSettings.Ambient then
                 _G.NormalLightingSettings.Ambient = game:GetService("Lighting").Ambient
                 if not _G.FullBrightEnabled then
                    repeat
                       wait()
                    until _G.FullBrightEnabled
                 end
                 game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
              end
              end)
      
              game:GetService("Lighting").Brightness = 1
              game:GetService("Lighting").ClockTime = 12
              game:GetService("Lighting").FogEnd = 786543
              game:GetService("Lighting").GlobalShadows = false
              game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
      
              local LatestValue = true
              spawn(function()
              repeat
                 wait()
              until _G.FullBrightEnabled
              while wait() do
                 if _G.FullBrightEnabled ~= LatestValue then
                    if not _G.FullBrightEnabled then
                       game:GetService("Lighting").Brightness = _G.NormalLightingSettings.Brightness
                       game:GetService("Lighting").ClockTime = _G.NormalLightingSettings.ClockTime
                       game:GetService("Lighting").FogEnd = _G.NormalLightingSettings.FogEnd
                       game:GetService("Lighting").GlobalShadows = _G.NormalLightingSettings.GlobalShadows
                       game:GetService("Lighting").Ambient = _G.NormalLightingSettings.Ambient
                    else
                       game:GetService("Lighting").Brightness = 1
                       game:GetService("Lighting").ClockTime = 12
                       game:GetService("Lighting").FogEnd = 786543
                       game:GetService("Lighting").GlobalShadows = false
                       game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
                    end
                    LatestValue = not LatestValue
                 end
              end
              end)
           end
      
           _G.FullBrightExecuted = true
           _G.FullBrightEnabled = not _G.FullBrightEnabled
      end)
   
      
      
      
      
      
      --Misc
      
      
      MiscPage:AddBind("Toggle GUI", Enum.KeyCode.F8, function()
          ShowerLib:OpenClose() -- opens or closes the UI
      end)
      
      MiscPage:AddButton("Destroy GUI", function()
          ShowerLib:Destroy() -- Kills the GUI
      end)
      end






   if game.PlaceId == 6010982997 then
      Loaded = true
      print("FLUX: Game Death Zone.")
          --Made by : https://v3rmillion.net/member.php?action=profile&uid=1591342
       
      local ShowerLib = loadstring(game:HttpGet("https://fluxteam.xyz/scripts/others/ShowerHeadLibrary.lua"))()
      local ESP = loadstring(game:HttpGet"https://raw.githubusercontent.com/dawid-scripts/Helios-Hub/main/Scripts/HeliosESP.lua")()
      local Window = ShowerLib:CreateWindow("F"); --Clicking this will make it rotate.
      local HomePage = Window:Section("Aim")
      local SelfPage = Window:Section("Self")
      local VisualsPage = Window:Section("Visual")
      local MiscPage = Window:Section("Misc")
      ESP:SetESPColor(Color3.fromRGB(0, 166, 255))
      
      
      --Configuration
      --Circle
      local FOVAmount = ""
   
   
      --Load settings
      local LightingModuleDeleted = false
      --Configuration
      
      HomePage:AddSlider("FOV", 100, 400, 10, function(Value)
          FOVAmount = Value -- Value is the value of the slider
      end)
   
      local SelectedBodyPart = "Random"
   
      HomePage:AddDrop(
              "Aimed Part",
              {
                  "Head",
                  "Body",
                  "Random"
              },
              function(value)
                  SelectedBodyPart = value
              end
          )
      
      HomePage:AddToggle("Silent Aim", function(state)
          if state == true then
              -- settings, if you want to change some settings just re-execute.
              _G.whitelist = {
                 "ItsIofty"
              }
              _G.friendsListIsWhitelisted = true -- change if you don't want to lock onto your friends
              _G.targetPart = SelectedBodyPart
              _G.bindEnabled = false
              _G.bind = Enum.KeyCode.E -- use the keycode reference: https://developer.roblox.com/en-us/api-reference/enum/KeyCode, this keydisables aimbot
      
              _G.FOV = FOVAmount
      
              -- This is primarily useful in first person shooters, note, wallbang will not work when you disable this.
              local RAYCAST_ENABLED = true
              -- -- This is rarely useful, however in some cases you might want it.
              local MOUSE_TARGET_ENABLED = false
              -- This is useful for most third person shooters.  It will function very well if you're having bugs, switch to mouse position.
              local MOUSE_HIT_ENABLED = false
              -- If you want to spoof the mouse's x and y coordinated on the screen.  usually if it's a 3rd person shooter it will use this or mouse hit.
              local MOUSE_POSITION_ENABLED = false
              -- I'm not sure what you're going to use this for, but it works I guess
              local MOUSE_ORIGIN_ENABLED = false
      
              _G.indexTable = {
                 -- mainly for scripters, but basically these are mouse properties that you might want to enable/disable if it's bugging out.
                 ["Mouse"] = {
                    ["target"] = {
                       Function = function(self, value)
                       return _G.closestCharacter[_G.targetPart]
                       end,
                       Enabled = MOUSE_TARGET_ENABLED
                    },
                    ["hit"] = {
                       Function = function(self, value)
                       return _G.closestCharacter[_G.targetPart].CFrame
                       end,
                       Enabled = MOUSE_HIT_ENABLED
                    },
                    ["origin"] = {
                       Function = function(self, value)
                       return CFrame.new(value.Position, _G.closestCharacter[_G.targetPart].Position)
                       end,
                       Enabled = MOUSE_ORIGIN_ENABLED
                    },
                    ["x"] = {
                       Function = function(self, value)
                       return uis:GetMouseLocation().X
                       end,
                       Enabled = MOUSE_POSITION_ENABLED
                    },
                    ["y"] = {
                       Function = function(self, value)
                       return uis:GetMouseLocation().Y
                       end,
                       Enabled = MOUSE_POSITION_ENABLED
                    },
                    ["unitray"] = {
                       Function = function(self, value)
                       return Ray.new(
                       self.Origin.Position,
                       (_G.closestCharacter[_G.targetPart].Position - self.Origin.Position).Unit
                       )
                       end,
                       Enabled = RAYCAST_ENABLED
                    }
                 },
                 ["Humanoid"] = {
                    ["targetpoint"] = {
                       Function = function(self, value)
                       return _G.closestCharacter[_G.targetPart].Position
                       end,
                       Enabled = MOUSE_HIT_ENABLED
                    }
                 }
              }
      
              _G.namecallTable = {
                 ["getmouselocation"] = {
                    Function = function(self, returns, args)
                    local vector =
                    workspace.CurrentCamera.WorldToViewportPoint(
                    workspace.CurrentCamera,
                    _G.closestCharacter[_G.targetPart].Position
                    )
                    returns[1] = Vector2.new(vector.X, vector.Y)
                    return returns
                    end,
                    Enabled = MOUSE_POSITION_ENABLED
                 },
                 ["findpartonraywithignorelist"] = {
                    Function = function(self, returns, args)
                    args[1] =
                    Ray.new(
                    mouse.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                    0,
                    (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                    0
                    ) -
                    mouse.Origin.Position).unit * 500
                    )
                    if not _G.wallbang then
                       returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                    else
                       args[2] = {}
                       for _, player in ipairs(game.Players:GetPlayers()) do
                          if player.Character then
                             table.insert(args[2], player.Character)
                          end
                       end
                       returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                    end
                    return returns
                    end,
                    Enabled = RAYCAST_ENABLED
                 },
                 ["findpartonray"] = {
                    Function = function(self, returns, args)
                    args[1] =
                    Ray.new(
                    mouse.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                    0,
                    (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                    0
                    ) -
                    mouse.Origin.Position).unit * 500
                    )
                    if not args[2] then
                       args[2] = {}
                    end
                    if not _G.wallbang then
                       returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                    else
                       args[2] = {}
                       for _, player in ipairs(game.Players:GetPlayers()) do
                          if player.Character then
                             table.insert(args[2], player.Character)
                          end
                       end
                       returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                    end
                    return returns
                    end,
                    Enabled = RAYCAST_ENABLED
                 },
                 ["findpartonraywithwhitelist"] = {
                    Function = function(self, returns, args)
                    args[1] =
                    Ray.new(
                    mouse.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                    0,
                    (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                    0
                    ) -
                    mouse.Origin.Position).unit * 500
                    )
                    if not _G.wallbang then
                       returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                    else
                       for _, player in ipairs(game.Players:GetPlayers()) do
                          if player.Character then
                             table.insert(args[2], player.Character)
                          end
                       end
                       returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                    end
      
                    return returns
                    end,
                    Enabled = RAYCAST_ENABLED
                 },
                 ["raycast"] = {
                    Function = function(self, returns, args)
                    args[1], args[2] =
                    mouse.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                    0,
                    (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                    0
                    ) -
                    mouse.Origin.Position).unit * 500
      
                    if not _G.wallbang then
                       returns = table.pack(self.Raycast(self, unpack(args)))
                    else
                       local FilterDescendantsInstances = args[3].FilterDescendantsInstances
                       local FilterType = Enum.RaycastFilterType.Whitelist
                       local IgnoreWater = args[3].IgnoreWater
                       local CollisionGroup = args[3].CollisionGroup
                       args[3] =
                       RaycastParams.new(
                       {
                          FilterDescendantsInstances = FilterDescendantsInstances,
                          FilterType = FilterType,
                          IgnoreWater = IgnoreWater,
                          CollisionGroup = CollisionGroup
                       }
                       )
                       returns = table.pack(self.Raycast(self, unpack(args)))
                    end
      
                    return returns
                    end,
                    Enabled = RAYCAST_ENABLED
                 }
              }
      
              -- the actual script
              local getnamecallmethod = getnamecallmethod or getnamecall_method
              local newcclosure = newcclosure or hide_me or function(func)
              return func
           end
      
           local checkcaller = checkcaller or is_protosmasher_caller or Cer.isCerus
      
           uis = game:GetService("UserInputService")
           local player = game.Players.LocalPlayer
           mouse = player:GetMouse()
      
           local mt = getrawmetatable(game)
      
           local mt_index, mt_namecall = mt.__index, mt.__namecall
      
           if setreadonly then
              setreadonly(mt, false)
           elseif make_writeable then
              make_writeable(mt, true)
           end
      
           function IsTeamMate(Player1, Player2)
              return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and
              Player1.TeamColor == Player2.TeamColor)
           end
      
           if not _G.MUTEX then
              _G.MUTEX = true
      
              local aimbot = true
              function mt:__index(index)
                 local value = mt_index(self, index)
      
                 if not checkcaller() then
                    if aimbot then
                       local table  -- im pretty sure this works like rawget for properties
                       for index, value in pairs(_G.indexTable) do
                          if self:IsA(index) then
                             table = value
                             break
                          end
                       end
      
                       if table then
                          table = table[index:lower()]
                          if table then
                             if table.Enabled then
                                if _G.closestCharacter then
                                   return table.Function(self, value)
                                end
                             end
                          end
                       end
                    end
                 end
      
                 return value
              end
      
              function mt:__namecall(...)
                 local args = {
                    ...
                 }
      
                 local returns = table.pack(mt_namecall(self, unpack(args)))
      
                 if aimbot then
                    local table = _G.namecallTable[getnamecallmethod():lower()]
                    if table then
                       if table.Enabled then
                          if _G.closestCharacter then
                             returns = table.Function(self, returns, args)
                          end
                       end
                    end
                 end
      
                 return unpack(returns)
              end
      
              uis.InputBegan:Connect(
              function(input, gameProcessed)
                 if not gameProcessed and _G.bindEnabled then
                    if input.KeyCode == _G.bind then
                       aimbot = not aimbot
                    end
                 end
              end
              )
      
              while wait() do
                 pcall(
                 function()
                    -- because this shit breaks like 24/7
                    _G.closestCharacter, closestDistance = nil, math.huge
                    for _, currentPlayer in ipairs(game.Players:GetPlayers()) do
                       if not table.find(_G.whitelist, currentPlayer.Name) then
                          if currentPlayer ~= game.Players.LocalPlayer then
                             local character = currentPlayer.Character
                             if character then
                                local humanoid = character:FindFirstChildWhichIsA("Humanoid")
                                if humanoid and humanoid.Health > 0 and not IsTeamMate(player, currentPlayer) then
                                   if
                                   not _G.friendsListIsWhitelisted or
                                   (_G.friendsListIsWhitelisted and
                                   not currentPlayer:IsFriendsWith(player.UserId))
                                   then
                                      local vector, onScreen =
                                      workspace.CurrentCamera:WorldToScreenPoint(
                                      character[_G.targetPart].Position
                                      )
                                      if onScreen then
                                         local magnitude =
                                         (Vector2.new(mouse.X, mouse.Y) - Vector2.new(vector.X, vector.Y)).magnitude
                                         if magnitude < closestDistance then
                                            if magnitude <= _G.FOV then
                                               _G.closestCharacter, closestDistance = character, magnitude
                                            end
                                         end
                                      end
                                   end
                                end
                             end
                          end
                       end
                    end
                 end
                 )
              end
           end
        else
           -- settings, if you want to change some settings just re-execute.
           _G.whitelist = {
              "ItsIofty"
           }
           _G.friendsListIsWhitelisted = true -- change if you don't want to lock onto your friends
           _G.targetPart = "Head"
           _G.bindEnabled = false
           _G.bind = Enum.KeyCode.E -- use the keycode reference: https://developer.roblox.com/en-us/api-reference/enum/KeyCode, this keydisables aimbot
      
           _G.FOV = 0
      
           -- This is primarily useful in first person shooters, note, wallbang will not work when you disable this.
           local RAYCAST_ENABLED = true
           -- -- This is rarely useful, however in some cases you might want it.
           local MOUSE_TARGET_ENABLED = false
           -- This is useful for most third person shooters.  It will function very well if you're having bugs, switch to mouse position.
           local MOUSE_HIT_ENABLED = false
           -- If you want to spoof the mouse's x and y coordinated on the screen.  usually if it's a 3rd person shooter it will use this or mouse hit.
           local MOUSE_POSITION_ENABLED = false
           -- I'm not sure what you're going to use this for, but it works I guess
           local MOUSE_ORIGIN_ENABLED = false
      
           _G.indexTable = {
              -- mainly for scripters, but basically these are mouse properties that you might want to enable/disable if it's bugging out.
              ["Mouse"] = {
                 ["target"] = {
                    Function = function(self, value)
                    return _G.closestCharacter[_G.targetPart]
                    end,
                    Enabled = MOUSE_TARGET_ENABLED
                 },
                 ["hit"] = {
                    Function = function(self, value)
                    return _G.closestCharacter[_G.targetPart].CFrame
                    end,
                    Enabled = MOUSE_HIT_ENABLED
                 },
                 ["origin"] = {
                    Function = function(self, value)
                    return CFrame.new(value.Position, _G.closestCharacter[_G.targetPart].Position)
                    end,
                    Enabled = MOUSE_ORIGIN_ENABLED
                 },
                 ["x"] = {
                    Function = function(self, value)
                    return uis:GetMouseLocation().X
                    end,
                    Enabled = MOUSE_POSITION_ENABLED
                 },
                 ["y"] = {
                    Function = function(self, value)
                    return uis:GetMouseLocation().Y
                    end,
                    Enabled = MOUSE_POSITION_ENABLED
                 },
                 ["unitray"] = {
                    Function = function(self, value)
                    return Ray.new(
                    self.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position - self.Origin.Position).Unit
                    )
                    end,
                    Enabled = RAYCAST_ENABLED
                 }
              },
              ["Humanoid"] = {
                 ["targetpoint"] = {
                    Function = function(self, value)
                    return _G.closestCharacter[_G.targetPart].Position
                    end,
                    Enabled = MOUSE_HIT_ENABLED
                 }
              }
           }
      
           _G.namecallTable = {
              ["getmouselocation"] = {
                 Function = function(self, returns, args)
                 local vector =
                 workspace.CurrentCamera.WorldToViewportPoint(
                 workspace.CurrentCamera,
                 _G.closestCharacter[_G.targetPart].Position
                 )
                 returns[1] = Vector2.new(vector.X, vector.Y)
                 return returns
                 end,
                 Enabled = MOUSE_POSITION_ENABLED
              },
              ["findpartonraywithignorelist"] = {
                 Function = function(self, returns, args)
                 args[1] =
                 Ray.new(
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
                 )
                 if not _G.wallbang then
                    returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                 else
                    args[2] = {}
                    for _, player in ipairs(game.Players:GetPlayers()) do
                       if player.Character then
                          table.insert(args[2], player.Character)
                       end
                    end
                    returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                 end
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              },
              ["findpartonray"] = {
                 Function = function(self, returns, args)
                 args[1] =
                 Ray.new(
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
                 )
                 if not args[2] then
                    args[2] = {}
                 end
                 if not _G.wallbang then
                    returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                 else
                    args[2] = {}
                    for _, player in ipairs(game.Players:GetPlayers()) do
                       if player.Character then
                          table.insert(args[2], player.Character)
                       end
                    end
                    returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                 end
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              },
              ["findpartonraywithwhitelist"] = {
                 Function = function(self, returns, args)
                 args[1] =
                 Ray.new(
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
                 )
                 if not _G.wallbang then
                    returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
                 else
                    for _, player in ipairs(game.Players:GetPlayers()) do
                       if player.Character then
                          table.insert(args[2], player.Character)
                       end
                    end
                    returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
                 end
      
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              },
              ["raycast"] = {
                 Function = function(self, returns, args)
                 args[1], args[2] =
                 mouse.Origin.Position,
                 (_G.closestCharacter[_G.targetPart].Position +
                 Vector3.new(
                 0,
                 (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                 0
                 ) -
                 mouse.Origin.Position).unit * 500
      
                 if not _G.wallbang then
                    returns = table.pack(self.Raycast(self, unpack(args)))
                 else
                    local FilterDescendantsInstances = args[3].FilterDescendantsInstances
                    local FilterType = Enum.RaycastFilterType.Whitelist
                    local IgnoreWater = args[3].IgnoreWater
                    local CollisionGroup = args[3].CollisionGroup
                    args[3] =
                    RaycastParams.new(
                    {
                       FilterDescendantsInstances = FilterDescendantsInstances,
                       FilterType = FilterType,
                       IgnoreWater = IgnoreWater,
                       CollisionGroup = CollisionGroup
                    }
                    )
                    returns = table.pack(self.Raycast(self, unpack(args)))
                 end
      
                 return returns
                 end,
                 Enabled = RAYCAST_ENABLED
              }
           }
      
           -- the actual script
           local getnamecallmethod = getnamecallmethod or getnamecall_method
           local newcclosure = newcclosure or hide_me or function(func)
           return func
        end
      
        local checkcaller = checkcaller or is_protosmasher_caller or Cer.isCerus
      
        uis = game:GetService("UserInputService")
        local player = game.Players.LocalPlayer
        mouse = player:GetMouse()
      
        local mt = getrawmetatable(game)
      
        local mt_index, mt_namecall = mt.__index, mt.__namecall
      
        if setreadonly then
           setreadonly(mt, false)
        elseif make_writeable then
           make_writeable(mt, true)
        end
      
        function IsTeamMate(Player1, Player2)
           return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and
           Player1.TeamColor == Player2.TeamColor)
        end
      
        if not _G.MUTEX then
           _G.MUTEX = true
      
           local aimbot = true
           function mt:__index(index)
              local value = mt_index(self, index)
      
              if not checkcaller() then
                 if aimbot then
                    local table  -- im pretty sure this works like rawget for properties
                    for index, value in pairs(_G.indexTable) do
                       if self:IsA(index) then
                          table = value
                          break
                       end
                    end
      
                    if table then
                       table = table[index:lower()]
                       if table then
                          if table.Enabled then
                             if _G.closestCharacter then
                                return table.Function(self, value)
                             end
                          end
                       end
                    end
                 end
              end
      
              return value
           end
      
           function mt:__namecall(...)
              local args = {
                 ...
              }
      
              local returns = table.pack(mt_namecall(self, unpack(args)))
      
              if aimbot then
                 local table = _G.namecallTable[getnamecallmethod():lower()]
                 if table then
                    if table.Enabled then
                       if _G.closestCharacter then
                          returns = table.Function(self, returns, args)
                       end
                    end
                 end
              end
      
              return unpack(returns)
           end
      
           uis.InputBegan:Connect(
           function(input, gameProcessed)
              if not gameProcessed and _G.bindEnabled then
                 if input.KeyCode == _G.bind then
                    aimbot = not aimbot
                 end
              end
           end
           )
      
           while wait() do
              pcall(
              function()
                 -- because this shit breaks like 24/7
                 _G.closestCharacter, closestDistance = nil, math.huge
                 for _, currentPlayer in ipairs(game.Players:GetPlayers()) do
                    if not table.find(_G.whitelist, currentPlayer.Name) then
                       if currentPlayer ~= game.Players.LocalPlayer then
                          local character = currentPlayer.Character
                          if character then
                             local humanoid = character:FindFirstChildWhichIsA("Humanoid")
                             if humanoid and humanoid.Health > 0 and not IsTeamMate(player, currentPlayer) then
                                if
                                not _G.friendsListIsWhitelisted or
                                (_G.friendsListIsWhitelisted and
                                not currentPlayer:IsFriendsWith(player.UserId))
                                then
                                   local vector, onScreen =
                                   workspace.CurrentCamera:WorldToScreenPoint(
                                   character[_G.targetPart].Position
                                   )
                                   if onScreen then
                                      local magnitude =
                                      (Vector2.new(mouse.X, mouse.Y) - Vector2.new(vector.X, vector.Y)).magnitude
                                      if magnitude < closestDistance then
                                         if magnitude <= _G.FOV then
                                            _G.closestCharacter, closestDistance = character, magnitude
                                         end
                                      end
                                   end
                                end
                             end
                          end
                       end
                    end
                 end
              end
              )
           end
        end
      end
      end)
   
      HomePage:AddButton("No Recoil", function()
       game.Players.LocalPlayer.Backpack.WalkAnimation.recoil.antirecoil:Destroy()
      end)
      
      
      
      --Self
      SelfPage:AddToggle("Walkspeed", function(State)
          if state == true then
              while wait(1) do
                 Speed = 1 -- 1 is pretty much good but you do you :D
      
                 _G.Speed = true -- Toggle Speed
      
                 You = game.Players.LocalPlayer.Name
                 UIS = game:GetService("UserInputService")
      
                 while _G.Speed do
                    if UIS:IsKeyDown(Enum.KeyCode.W) then
                       game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,-Speed)
                       end;
                       if UIS:IsKeyDown(Enum.KeyCode.A) then
                          game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(-Speed,0,0)
                          end;
                          if UIS:IsKeyDown(Enum.KeyCode.S) then
                             game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,Speed)
                             end;
                             if UIS:IsKeyDown(Enum.KeyCode.D) then
                                game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(Speed,0,0)
                                end;
                                wait()
                             end
                          end
                       else
                          while wait(1) do
                             Speed = 1 -- 1 is pretty much good but you do you :D
      
                             _G.Speed = false -- Toggle Speed
      
                             You = game.Players.LocalPlayer.Name
                             UIS = game:GetService("UserInputService")
      
                             while _G.Speed do
                                if UIS:IsKeyDown(Enum.KeyCode.W) then
                                   game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,-Speed)
                                   end;
                                   if UIS:IsKeyDown(Enum.KeyCode.A) then
                                      game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(-Speed,0,0)
                                      end;
                                      if UIS:IsKeyDown(Enum.KeyCode.S) then
                                         game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(0,0,Speed)
                                         end;
                                         if UIS:IsKeyDown(Enum.KeyCode.D) then
                                            game:GetService("Workspace")[You].HumanoidRootPart.CFrame = game:GetService("Workspace")[You].HumanoidRootPart.CFrame * CFrame.new(Speed,0,0)
                                            end;
                                            wait()
                                         end
                                      end
                                   end
      end)
      
      
      SelfPage:AddButton("Fly", function()
          loadstring(game:HttpGet(('https://pastebin.com/raw/WxmvCLLH'),true))()
      end)
      
      SelfPage:AddButton("Low Gravity", function()
          local p = game.Players.LocalPlayer.Character.HumanoidRootPart
      local yeah_this_is_yeah = Instance.new("BodyForce")
      yeah_this_is_yeah.Parent = p
      yeah_this_is_yeah.Force = Vector3.new(0, 2000, 0)
      end)
      
      
      
      --Visual
      VisualsPage:AddToggle("Box", function(state)
          ESP:BoxESPToggle(state)
      end)
      
      VisualsPage:AddToggle("Tracers", function(state)
          ESP:TracersToggle(state)
      end)
      
      VisualsPage:AddToggle("Names", function(state)
          ESP:NameESPToggle(state)
      end)
      
      VisualsPage:AddToggle("Teamcheck", function(state)
          ESP:TeamcheckToggle(state)
      end)
      
      VisualsPage:AddToggle("Chams", function(state)
          if state == true then
              local color = BrickColor.new(255, 0, 50)
              local transparency = 0
      
              local Players = game:GetService("Players")
              local function _ESP(c)
                 repeat wait() until c.PrimaryPart ~= nil
                    for i,p in pairs(c:GetChildren()) do
                       if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                          if p:FindFirstChild("4329138913") then p.shit:Destroy() end
                          local a = Instance.new("BoxHandleAdornment",p)
                          a.Name = "4329138913"
                          a.Size = p.Size
                          a.Color = color
                          a.Transparency = transparency
                          a.AlwaysOnTop = true
                          a.Visible = true
                          a.Adornee = p
                          a.ZIndex = true
      
                       end
                    end
                 end
                 local function ESP()
                    for i,v in pairs(Players:GetChildren()) do
                       if v ~= game.Players.LocalPlayer then
                          if v.Character then
                             _ESP(v.Character)
                          end
                          v.CharacterAdded:Connect(function(chr)
                          _ESP(chr)
                          end)
                       end
                    end
                    Players.PlayerAdded:Connect(function(player)
                    player.CharacterAdded:Connect(function(chr)
                    _ESP(chr)
                    end)
                    end)
                 end
                 ESP()
      
      
      
              else
      
      
      
                 local color = BrickColor.new(255, 0, 50)
                 local transparency = 1
      
                 local Players = game:GetService("Players")
                 local function _ESP(c)
                    repeat wait() until c.PrimaryPart ~= nil
                       for i,p in pairs(c:GetChildren()) do
                          if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                             if p:FindFirstChild("4329138913") then p.shit:Destroy() end
                             local a = Instance.new("BoxHandleAdornment",p)
                             a.Name = "4329138913"
                             a.Size = p.Size
                             a.Color = color
                             a.Transparency = transparency
                             a.AlwaysOnTop = true
                             a.Visible = true
                             a.Adornee = p
                             a.ZIndex = true
      
                          end
                       end
                    end
                    local function ESP()
                       for i,v in pairs(Players:GetChildren()) do
                          if v ~= game.Players.LocalPlayer then
                             if v.Character then
                                _ESP(v.Character)
                             end
                             v.CharacterAdded:Connect(function(chr)
                             _ESP(chr)
                             end)
                          end
                       end
                       Players.PlayerAdded:Connect(function(player)
                       player.CharacterAdded:Connect(function(chr)
                       _ESP(chr)
                       end)
                       end)
                    end
                    ESP()
                 end
      end)
   
      VisualsPage:AddLabel("Player")
   
      VisualsPage:AddToggle("Gun Chams", function(state)
       if state == true then
           for i,v in pairs(workspace:GetDescendants()) do
               if v:IsA("LeftHand") or v:IsA("RightHand") or v:IsA("MeshPart") then
               v.Material = "ForceField"
               end
               end
               for i,v in pairs(game:GetDescendants()) do
               if v:IsA("Light") or v:IsA("ParticleEmitter") or v:IsA("Trail") then
               v:Destroy()
               end
               end
       else
           for i,v in pairs(workspace:GetDescendants()) do
               if v:IsA("LeftHand") or v:IsA("RightHand") or v:IsA("MeshPart") then
               v.Material = "SmoothPlastic"
               end
               end
       end
      end)
      
      circle = Drawing.new("Circle")
      
      VisualsPage:AddToggle("View FOV", function(state)
          if state == true then
              circle = Drawing.new("Circle")
              circle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
              circle.Color = Color3.fromRGB(143, 59, 87)
              circle.Thickness = 1.5
              circle.NumSides = 100
              circle.Radius = FOVAmount
              circle.Visible = true
              circle.Filled = false
      
              local RunService = game:GetService("RunService")
              local player = game.Players.LocalPlayer
              local mouse = player:GetMouse()
              local gi=game:GetService('GuiService'):GetGuiInset();
      
              RunService.Heartbeat:Connect(function()
              circle.Position = Vector2.new(mouse.X, mouse.Y+gi.Y)
              end)
           else
              circle = Drawing.new("Circle")
              circle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
              circle.Color = Color3.fromRGB(143, 59, 87)
              circle.Thickness = 0
              circle.NumSides = 100
              circle.Radius = 0
              circle.Visible = false
              circle.Filled = false
      
              local RunService = game:GetService("RunService")
              local player = game.Players.LocalPlayer
              local mouse = player:GetMouse()
              local gi=game:GetService('GuiService'):GetGuiInset();
      
              RunService.Heartbeat:Connect(function()
              circle.Position = Vector2.new(mouse.X, mouse.Y+gi.Y)
              end)
           end
      end)
      
      VisualsPage:AddLabel("Map")
      
      VisualsPage:AddButton("Fullbright", function()
          if not _G.FullBrightExecuted then
      
              _G.FullBrightEnabled = false
      
              _G.NormalLightingSettings = {
                 Brightness = game:GetService("Lighting").Brightness,
                 ClockTime = game:GetService("Lighting").ClockTime,
                 FogEnd = game:GetService("Lighting").FogEnd,
                 GlobalShadows = game:GetService("Lighting").GlobalShadows,
                 Ambient = game:GetService("Lighting").Ambient
              }
      
              game:GetService("Lighting"):GetPropertyChangedSignal("Brightness"):Connect(function()
              if game:GetService("Lighting").Brightness ~= 1 and game:GetService("Lighting").Brightness ~= _G.NormalLightingSettings.Brightness then
                 _G.NormalLightingSettings.Brightness = game:GetService("Lighting").Brightness
                 if not _G.FullBrightEnabled then
                    repeat
                       wait()
                    until _G.FullBrightEnabled
                 end
                 game:GetService("Lighting").Brightness = 1
              end
              end)
      
              game:GetService("Lighting"):GetPropertyChangedSignal("ClockTime"):Connect(function()
              if game:GetService("Lighting").ClockTime ~= 12 and game:GetService("Lighting").ClockTime ~= _G.NormalLightingSettings.ClockTime then
                 _G.NormalLightingSettings.ClockTime = game:GetService("Lighting").ClockTime
                 if not _G.FullBrightEnabled then
                    repeat
                       wait()
                    until _G.FullBrightEnabled
                 end
                 game:GetService("Lighting").ClockTime = 12
              end
              end)
      
              game:GetService("Lighting"):GetPropertyChangedSignal("FogEnd"):Connect(function()
              if game:GetService("Lighting").FogEnd ~= 786543 and game:GetService("Lighting").FogEnd ~= _G.NormalLightingSettings.FogEnd then
                 _G.NormalLightingSettings.FogEnd = game:GetService("Lighting").FogEnd
                 if not _G.FullBrightEnabled then
                    repeat
                       wait()
                    until _G.FullBrightEnabled
                 end
                 game:GetService("Lighting").FogEnd = 786543
              end
              end)
      
              game:GetService("Lighting"):GetPropertyChangedSignal("GlobalShadows"):Connect(function()
              if game:GetService("Lighting").GlobalShadows ~= false and game:GetService("Lighting").GlobalShadows ~= _G.NormalLightingSettings.GlobalShadows then
                 _G.NormalLightingSettings.GlobalShadows = game:GetService("Lighting").GlobalShadows
                 if not _G.FullBrightEnabled then
                    repeat
                       wait()
                    until _G.FullBrightEnabled
                 end
                 game:GetService("Lighting").GlobalShadows = false
              end
              end)
      
              game:GetService("Lighting"):GetPropertyChangedSignal("Ambient"):Connect(function()
              if game:GetService("Lighting").Ambient ~= Color3.fromRGB(178, 178, 178) and game:GetService("Lighting").Ambient ~= _G.NormalLightingSettings.Ambient then
                 _G.NormalLightingSettings.Ambient = game:GetService("Lighting").Ambient
                 if not _G.FullBrightEnabled then
                    repeat
                       wait()
                    until _G.FullBrightEnabled
                 end
                 game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
              end
              end)
      
              game:GetService("Lighting").Brightness = 1
              game:GetService("Lighting").ClockTime = 12
              game:GetService("Lighting").FogEnd = 786543
              game:GetService("Lighting").GlobalShadows = false
              game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
      
              local LatestValue = true
              spawn(function()
              repeat
                 wait()
              until _G.FullBrightEnabled
              while wait() do
                 if _G.FullBrightEnabled ~= LatestValue then
                    if not _G.FullBrightEnabled then
                       game:GetService("Lighting").Brightness = _G.NormalLightingSettings.Brightness
                       game:GetService("Lighting").ClockTime = _G.NormalLightingSettings.ClockTime
                       game:GetService("Lighting").FogEnd = _G.NormalLightingSettings.FogEnd
                       game:GetService("Lighting").GlobalShadows = _G.NormalLightingSettings.GlobalShadows
                       game:GetService("Lighting").Ambient = _G.NormalLightingSettings.Ambient
                    else
                       game:GetService("Lighting").Brightness = 1
                       game:GetService("Lighting").ClockTime = 12
                       game:GetService("Lighting").FogEnd = 786543
                       game:GetService("Lighting").GlobalShadows = false
                       game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
                    end
                    LatestValue = not LatestValue
                 end
              end
              end)
           end
      
           _G.FullBrightExecuted = true
           _G.FullBrightEnabled = not _G.FullBrightEnabled
      end)
   
      
      
      
      
      
      --Misc
      
      
      MiscPage:AddBind("Toggle GUI", Enum.KeyCode.F8, function()
          ShowerLib:OpenClose() -- opens or closes the UI
      end)
      
      MiscPage:AddButton("Destroy GUI", function()
          ShowerLib:Destroy() -- Kills the GUI
      end)
      end
   
   
   
   
      --seperator new game







   if game.PlaceId == 2512643572 then -- Bubble gum simulator
      --Func
      local cccc = require(game:GetService("ReplicatedStorage").Assets.Modules.EggService)
    repeat
        wait()
        cccc = require(game:GetService("ReplicatedStorage").Assets.Modules.EggService)
    until cccc ~= nil
    local hat1 = cccc.HatchEgg
    local hat3 = cccc.MultiHatchEgg



      Loaded = true
       --Made by : https://v3rmillion.net/member.php?action=profile&uid=1591342
   
       local ShowerLib = loadstring(game:HttpGet("https://fluxteam.xyz/scripts/others/ShowerHeadLibrary.lua"))()
       local ESP =
           loadstring(game:HttpGet "https://raw.githubusercontent.com/dawid-scripts/Helios-Hub/main/Scripts/HeliosESP.lua")(
   
       )
       local Window = ShowerLib:CreateWindow("F") --Clicking this will make it rotate.
       local HomePage = Window:Section("Auto-Farm")
       local SelfPage = Window:Section("Self")
       local VisualsPage = Window:Section("Visual")
       local MiscPage = Window:Section("Misc")
       ESP:SetESPColor(Color3.fromRGB(0, 166, 255))
   
       --Configuration
       local EggName = ""
   
       --Circle
       local FOVAmount = ""
   
       --Configuration
   
       HomePage:AddDrop(
           "Egg Name",
           {
               "Common Egg",
               "Nightmare Egg",
               "Jelly Egg",
               "Dominus Egg",
               "Water Egg",
               "Coral Egg",
               "Ancient Egg",
               "Colorful Egg",
               "Fancy Egg",
               "Sparkly Egg",
               "Holly Egg",
               "Gingerbread Egg",
               "Blizzard Egg",
               "Christmasy Egg",
               "2020 Egg",
               "1B Egg"
           },
           function(value)
               EggName = value
           end
       )
   
       HomePage:AddToggle(
           "Enabled",
           function(state)
               if state == true then
                   _G.OpAutoFarm = true
                   while wait() and _G.OpAutoFarm do
                       local args = {
                           [1] = "PurchaseEgg",
                           [2] = EggName,
                           [3] = "Multi"
                       }
   
                       game:GetService("ReplicatedStorage").NetworkRemoteEvent:FireServer(unpack(args))
   
                       local args = {
                           [1] = "BlowBubble"
                       }
   
                       game:GetService("ReplicatedStorage").NetworkRemoteEvent:FireServer(unpack(args))
                   end
               else
                   _G.OpAutoFarm = false
                   while wait() and _G.OpAutoFarm do
                       local args = {
                           [1] = "PurchaseEgg",
                           [2] = EggName,
                           [3] = "Multi"
                       }
   
                       game:GetService("ReplicatedStorage").NetworkRemoteEvent:FireServer(unpack(args))
   
                       local args = {
                           [1] = "BlowBubble"
                       }
   
                       game:GetService("ReplicatedStorage").NetworkRemoteEvent:FireServer(unpack(args))
                   end
               end
           end
       )

       HomePage:AddToggle(
           "Skip Animation",
           function(state)
            cccc.HatchEgg = (state == true and function()end or hat1)
            cccc.MultiHatchEgg = (state == true and function()end or hat3)
           end
         )
   
       HomePage:AddButton(
           "Anti-Afk",
           function()
               local VirtualUser = game:service "VirtualUser"
               game:service "Players".LocalPlayer.Idled:connect(
                   function()
                       VirtualUser:CaptureController()
                       VirtualUser:ClickButton2(Vector2.new())
                   end
               )
           end
       )
   
       --Self
       SelfPage:AddSlider(
           "Walkspeed",
           16,
           180,
           10,
           function(Value)
               game:GetService("Players").LocalPlayer.Character.Humanoid.WalkSpeed = Value -- Value is the value of the slider
           end
       )
   
       SelfPage:AddButton(
           "Fly",
           function()
               loadstring(game:HttpGet(("https://pastebin.com/raw/WxmvCLLH"), true))()
           end
       )
   
       --Visual
       VisualsPage:AddToggle(
           "Box",
           function(state)
               ESP:BoxESPToggle(state)
           end
       )
   
       VisualsPage:AddToggle(
           "Tracers",
           function(state)
               ESP:TracersToggle(state)
           end
       )
   
       VisualsPage:AddToggle(
           "Names",
           function(state)
               ESP:NameESPToggle(state)
           end
       )
   
       VisualsPage:AddToggle(
           "Teamcheck",
           function(state)
               ESP:TeamcheckToggle(state)
           end
       )
   
       VisualsPage:AddToggle(
           "Chams",
           function(state)
               if state == true then
                   local color = BrickColor.new(255, 0, 50)
                   local transparency = 0
   
                   local Players = game:GetService("Players")
                   local function _ESP(c)
                       repeat
                           wait()
                       until c.PrimaryPart ~= nil
                       for i, p in pairs(c:GetChildren()) do
                           if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                               if p:FindFirstChild("4329138913") then
                                   p.shit:Destroy()
                               end
                               local a = Instance.new("BoxHandleAdornment", p)
                               a.Name = "4329138913"
                               a.Size = p.Size
                               a.Color = color
                               a.Transparency = transparency
                               a.AlwaysOnTop = true
                               a.Visible = true
                               a.Adornee = p
                               a.ZIndex = true
                           end
                       end
                   end
                   local function ESP()
                       for i, v in pairs(Players:GetChildren()) do
                           if v ~= game.Players.LocalPlayer then
                               if v.Character then
                                   _ESP(v.Character)
                               end
                               v.CharacterAdded:Connect(
                                   function(chr)
                                       _ESP(chr)
                                   end
                               )
                           end
                       end
                       Players.PlayerAdded:Connect(
                           function(player)
                               player.CharacterAdded:Connect(
                                   function(chr)
                                       _ESP(chr)
                                   end
                               )
                           end
                       )
                   end
                   ESP()
               else
                   local color = BrickColor.new(255, 0, 50)
                   local transparency = 1
   
                   local Players = game:GetService("Players")
                   local function _ESP(c)
                       repeat
                           wait()
                       until c.PrimaryPart ~= nil
                       for i, p in pairs(c:GetChildren()) do
                           if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                               if p:FindFirstChild("4329138913") then
                                   p.shit:Destroy()
                               end
                               local a = Instance.new("BoxHandleAdornment", p)
                               a.Name = "4329138913"
                               a.Size = p.Size
                               a.Color = color
                               a.Transparency = transparency
                               a.AlwaysOnTop = true
                               a.Visible = true
                               a.Adornee = p
                               a.ZIndex = true
                           end
                       end
                   end
                   local function ESP()
                       for i, v in pairs(Players:GetChildren()) do
                           if v ~= game.Players.LocalPlayer then
                               if v.Character then
                                   _ESP(v.Character)
                               end
                               v.CharacterAdded:Connect(
                                   function(chr)
                                       _ESP(chr)
                                   end
                               )
                           end
                       end
                       Players.PlayerAdded:Connect(
                           function(player)
                               player.CharacterAdded:Connect(
                                   function(chr)
                                       _ESP(chr)
                                   end
                               )
                           end
                       )
                   end
                   ESP()
               end
           end
       )
   
       VisualsPage:AddSlider(
           "Radius",
           100,
           400,
           10,
           function(Value)
               FOVAmount = Value -- Value is the value of the slider
           end
       )
   
       circle = Drawing.new("Circle")
   
       VisualsPage:AddToggle(
           "View FOV",
           function(state)
               if state == true then
                   circle = Drawing.new("Circle")
                   circle.Position =
                       Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
                   circle.Color = Color3.fromRGB(143, 59, 87)
                   circle.Thickness = 1.5
                   circle.NumSides = 100
                   circle.Radius = FOVAmount
                   circle.Visible = true
                   circle.Filled = false
   
                   local RunService = game:GetService("RunService")
                   local player = game.Players.LocalPlayer
                   local mouse = player:GetMouse()
                   local gi = game:GetService("GuiService"):GetGuiInset()
   
                   RunService.Heartbeat:Connect(
                       function()
                           circle.Position = Vector2.new(mouse.X, mouse.Y + gi.Y)
                       end
                   )
               else
                   circle = Drawing.new("Circle")
                   circle.Position =
                       Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
                   circle.Color = Color3.fromRGB(143, 59, 87)
                   circle.Thickness = 0
                   circle.NumSides = 12
                   circle.Radius = 0
                   circle.Visible = false
                   circle.Filled = false
   
                   local RunService = game:GetService("RunService")
                   local player = game.Players.LocalPlayer
                   local mouse = player:GetMouse()
                   local gi = game:GetService("GuiService"):GetGuiInset()
   
                   RunService.Heartbeat:Connect(
                       function()
                           circle.Position = Vector2.new(mouse.X, mouse.Y + gi.Y)
                       end
                   )
               end
           end
       )
   
       VisualsPage:AddLabel("Map")
   
       VisualsPage:AddButton(
           "Fullbright",
           function()
               if not _G.FullBrightExecuted then
                   _G.FullBrightEnabled = false
   
                   _G.NormalLightingSettings = {
                       Brightness = game:GetService("Lighting").Brightness,
                       ClockTime = game:GetService("Lighting").ClockTime,
                       FogEnd = game:GetService("Lighting").FogEnd,
                       GlobalShadows = game:GetService("Lighting").GlobalShadows,
                       Ambient = game:GetService("Lighting").Ambient
                   }
   
                   game:GetService("Lighting"):GetPropertyChangedSignal("Brightness"):Connect(
                       function()
                           if
                               game:GetService("Lighting").Brightness ~= 1 and
                                   game:GetService("Lighting").Brightness ~= _G.NormalLightingSettings.Brightness
                            then
                               _G.NormalLightingSettings.Brightness = game:GetService("Lighting").Brightness
                               if not _G.FullBrightEnabled then
                                   repeat
                                       wait()
                                   until _G.FullBrightEnabled
                               end
                               game:GetService("Lighting").Brightness = 1
                           end
                       end
                   )
   
                   game:GetService("Lighting"):GetPropertyChangedSignal("ClockTime"):Connect(
                       function()
                           if
                               game:GetService("Lighting").ClockTime ~= 12 and
                                   game:GetService("Lighting").ClockTime ~= _G.NormalLightingSettings.ClockTime
                            then
                               _G.NormalLightingSettings.ClockTime = game:GetService("Lighting").ClockTime
                               if not _G.FullBrightEnabled then
                                   repeat
                                       wait()
                                   until _G.FullBrightEnabled
                               end
                               game:GetService("Lighting").ClockTime = 12
                           end
                       end
                   )
   
                   game:GetService("Lighting"):GetPropertyChangedSignal("FogEnd"):Connect(
                       function()
                           if
                               game:GetService("Lighting").FogEnd ~= 786543 and
                                   game:GetService("Lighting").FogEnd ~= _G.NormalLightingSettings.FogEnd
                            then
                               _G.NormalLightingSettings.FogEnd = game:GetService("Lighting").FogEnd
                               if not _G.FullBrightEnabled then
                                   repeat
                                       wait()
                                   until _G.FullBrightEnabled
                               end
                               game:GetService("Lighting").FogEnd = 786543
                           end
                       end
                   )
   
                   game:GetService("Lighting"):GetPropertyChangedSignal("GlobalShadows"):Connect(
                       function()
                           if
                               game:GetService("Lighting").GlobalShadows ~= false and
                                   game:GetService("Lighting").GlobalShadows ~= _G.NormalLightingSettings.GlobalShadows
                            then
                               _G.NormalLightingSettings.GlobalShadows = game:GetService("Lighting").GlobalShadows
                               if not _G.FullBrightEnabled then
                                   repeat
                                       wait()
                                   until _G.FullBrightEnabled
                               end
                               game:GetService("Lighting").GlobalShadows = false
                           end
                       end
                   )
   
                   game:GetService("Lighting"):GetPropertyChangedSignal("Ambient"):Connect(
                       function()
                           if
                               game:GetService("Lighting").Ambient ~= Color3.fromRGB(178, 178, 178) and
                                   game:GetService("Lighting").Ambient ~= _G.NormalLightingSettings.Ambient
                            then
                               _G.NormalLightingSettings.Ambient = game:GetService("Lighting").Ambient
                               if not _G.FullBrightEnabled then
                                   repeat
                                       wait()
                                   until _G.FullBrightEnabled
                               end
                               game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
                           end
                       end
                   )
   
                   game:GetService("Lighting").Brightness = 1
                   game:GetService("Lighting").ClockTime = 12
                   game:GetService("Lighting").FogEnd = 786543
                   game:GetService("Lighting").GlobalShadows = false
                   game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
   
                   local LatestValue = true
                   spawn(
                       function()
                           repeat
                               wait()
                           until _G.FullBrightEnabled
                           while wait() do
                               if _G.FullBrightEnabled ~= LatestValue then
                                   if not _G.FullBrightEnabled then
                                       game:GetService("Lighting").Brightness = _G.NormalLightingSettings.Brightness
                                       game:GetService("Lighting").ClockTime = _G.NormalLightingSettings.ClockTime
                                       game:GetService("Lighting").FogEnd = _G.NormalLightingSettings.FogEnd
                                       game:GetService("Lighting").GlobalShadows = _G.NormalLightingSettings.GlobalShadows
                                       game:GetService("Lighting").Ambient = _G.NormalLightingSettings.Ambient
                                   else
                                       game:GetService("Lighting").Brightness = 1
                                       game:GetService("Lighting").ClockTime = 12
                                       game:GetService("Lighting").FogEnd = 786543
                                       game:GetService("Lighting").GlobalShadows = false
                                       game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
                                   end
                                   LatestValue = not LatestValue
                               end
                           end
                       end
                   )
               end
   
               _G.FullBrightExecuted = true
               _G.FullBrightEnabled = not _G.FullBrightEnabled
           end
       )
   
       --Misc
   
       MiscPage:AddBind(
           "Toggle GUI",
           Enum.KeyCode.F8,
           function()
               ShowerLib:OpenClose() -- opens or closes the UI
           end
       )
   
       MiscPage:AddButton(
           "Destroy GUI",
           function()
               ShowerLib:Destroy() -- Kills the GUI
           end
       )
      end
      if game.PlaceId == 286090429 then --Arsenal
         Loaded = true
         --Made by : https://v3rmillion.net/member.php?action=profile&uid=1591342
          
         local ShowerLib = loadstring(game:HttpGet("https://fluxteam.xyz/scripts/others/ShowerHeadLibrary.lua"))()
         local ESP = loadstring(game:HttpGet"https://raw.githubusercontent.com/dawid-scripts/Helios-Hub/main/Scripts/HeliosESP.lua")()
         local Window = ShowerLib:CreateWindow("B"); --Clicking this will make it rotate.
         local HomePage = Window:Section("Aim")
         local SelfPage = Window:Section("Self")
         local VisualsPage = Window:Section("Visual")
         local MiscPage = Window:Section("Misc")
         ESP:SetESPColor(Color3.fromRGB(0, 166, 255))
         
         
         --Configuration
         local EggName = ""
         
         --Circle
         local FOVAmount = ""
         local CSides = ""
         
         --Configuration
         
         HomePage:AddToggle("Kill All [E]", function(State)
            loadstring(game:HttpGet("https://raw.githubusercontent.com/prestigedwinning/arsenalcool/main/ewf", State))()
         end)
         
         HomePage:AddToggle("Anti-Aim", function(State)
            game.RunService.Stepped:Connect(function()
               Game:GetService("ReplicatedStorage").Events.ControlTurn:FireServer(math.random(-1000,1000))
            end)
         end)
         
         HomePage:AddButton("Rapid fire", function()
            --// Don't bully i made this thing 1.2 years ago
         local Functions = {}
         for i,v in pairs(getreg()) do
            if type(v) == "function" then
                for i2,v2 in pairs(getfenv(v)) do
                    if type(v2) == "function" then
                        Functions[tostring(i2)] = v2
                    end
                end
            end
         end
         
         function GetLocalWeapon()
            return getfenv(Functions.usethatgun).gun
         end
         
         game:GetService("RunService"):BindToRenderStep("gunmodsarecool", 1, function()
            getfenv(Functions.usethatgun).currentspread = 0 -- NoSpread
         
            getfenv(Functions.usethatgun).recoil = 0 -- NoRecoil
         
            if GetLocalWeapon() ~= "none" and GetLocalWeapon():FindFirstChild("Ammo") then -- Inf Ammo
                debug.setupvalue(Functions["updateInventory"], 3, GetLocalWeapon():FindFirstChild("Ammo").Value)
            end
            
            if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Spawned") and game:GetService("UserInputService"):IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then -- RapidFire
                if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid").Health ~= 0 and game.Players.LocalPlayer.Character:FindFirstChild("Spawned") then
                    pcall(function()
                        Functions.firebullet(true)
                    end)
                end
            end
         end)
         end)
         
         
         
         --Self
         SelfPage:AddSlider("Walkspeed", 16, 200, 10, function(Value)
            game:GetService("Players").LocalPlayer.Character:WaitForChild("Humanoid"):GetPropertyChangedSignal("WalkSpeed"):Connect(function()
               setpropvalue(game:GetService("Players").LocalPlayer.Character:WaitForChild("Humanoid"), "WalkSpeed", Value)
           end)
         end)
         
         SelfPage:AddSlider("Jumpheight", 20, 200, 10, function(Value)
            game:GetService("Players").LocalPlayer.Character:WaitForChild("Humanoid"):GetPropertyChangedSignal("JumpPower"):Connect(function()
               setpropvalue(game:GetService("Players").LocalPlayer.Character:WaitForChild("Humanoid"), "JumpPower", Value)
           end)
         end)
         
         
         
         --Visual
         VisualsPage:AddToggle("Box", function(state)
             ESP:BoxESPToggle(state)
         end)
         
         VisualsPage:AddToggle("Tracers", function(state)
             ESP:TracersToggle(state)
         end)
         
         VisualsPage:AddToggle("Names", function(state)
             ESP:NameESPToggle(state)
         end)
         
         VisualsPage:AddToggle("Teamcheck", function(state)
             ESP:TeamcheckToggle(state)
         end)
         
         VisualsPage:AddToggle("Chams", function(state)
             if state == true then
                 local color = BrickColor.new(255, 0, 50)
                 local transparency = 0
         
                 local Players = game:GetService("Players")
                 local function _ESP(c)
                    repeat wait() until c.PrimaryPart ~= nil
                       for i,p in pairs(c:GetChildren()) do
                          if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                             if p:FindFirstChild("4329138913") then p.shit:Destroy() end
                             local a = Instance.new("BoxHandleAdornment",p)
                             a.Name = "4329138913"
                             a.Size = p.Size
                             a.Color = color
                             a.Transparency = transparency
                             a.AlwaysOnTop = true
                             a.Visible = true
                             a.Adornee = p
                             a.ZIndex = true
         
                          end
                       end
                    end
                    local function ESP()
                       for i,v in pairs(Players:GetChildren()) do
                          if v ~= game.Players.LocalPlayer then
                             if v.Character then
                                _ESP(v.Character)
                             end
                             v.CharacterAdded:Connect(function(chr)
                             _ESP(chr)
                             end)
                          end
                       end
                       Players.PlayerAdded:Connect(function(player)
                       player.CharacterAdded:Connect(function(chr)
                       _ESP(chr)
                       end)
                       end)
                    end
                    ESP()
         
         
         
                 else
         
         
         
                    local color = BrickColor.new(255, 0, 50)
                    local transparency = 1
         
                    local Players = game:GetService("Players")
                    local function _ESP(c)
                       repeat wait() until c.PrimaryPart ~= nil
                          for i,p in pairs(c:GetChildren()) do
                             if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                                if p:FindFirstChild("4329138913") then p.shit:Destroy() end
                                local a = Instance.new("BoxHandleAdornment",p)
                                a.Name = "4329138913"
                                a.Size = p.Size
                                a.Color = color
                                a.Transparency = transparency
                                a.AlwaysOnTop = true
                                a.Visible = true
                                a.Adornee = p
                                a.ZIndex = true
         
                             end
                          end
                       end
                       local function ESP()
                          for i,v in pairs(Players:GetChildren()) do
                             if v ~= game.Players.LocalPlayer then
                                if v.Character then
                                   _ESP(v.Character)
                                end
                                v.CharacterAdded:Connect(function(chr)
                                _ESP(chr)
                                end)
                             end
                          end
                          Players.PlayerAdded:Connect(function(player)
                          player.CharacterAdded:Connect(function(chr)
                          _ESP(chr)
                          end)
                          end)
                       end
                       ESP()
                    end
         end)
         
         VisualsPage:AddSlider("Radius", 100, 400, 10, function(Value)
             FOVAmount = Value -- Value is the value of the slider
         end)
         
         VisualsPage:AddSlider("Sides", 12, 100, 3, function(Value)
             CSides = Value -- Value is the value of the slider
         end)
         
         circle = Drawing.new("Circle")
         
         VisualsPage:AddToggle("View FOV", function(state)
             if state == true then
                 circle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
                 circle.Color = Color3.fromRGB(143, 59, 87)
                 circle.Thickness = 1.5
                 circle.NumSides = 100
                 circle.Radius = FOVAmount
                 circle.Visible = true
                 circle.Filled = false
         
                 local RunService = game:GetService("RunService")
                 local player = game.Players.LocalPlayer
                 local mouse = player:GetMouse()
                 local gi=game:GetService('GuiService'):GetGuiInset();
         
                 RunService.Heartbeat:Connect(function()
                 circle.Position = Vector2.new(mouse.X, mouse.Y+gi.Y)
                 end)
              else
                 circle.Destroy()
              end
         end)
         
         VisualsPage:AddLabel("Map")
         
         VisualsPage:AddButton("Fullbright", function()
             if not _G.FullBrightExecuted then
         
                 _G.FullBrightEnabled = false
         
                 _G.NormalLightingSettings = {
                    Brightness = game:GetService("Lighting").Brightness,
                    ClockTime = game:GetService("Lighting").ClockTime,
                    FogEnd = game:GetService("Lighting").FogEnd,
                    GlobalShadows = game:GetService("Lighting").GlobalShadows,
                    Ambient = game:GetService("Lighting").Ambient
                 }
         
                 game:GetService("Lighting"):GetPropertyChangedSignal("Brightness"):Connect(function()
                 if game:GetService("Lighting").Brightness ~= 1 and game:GetService("Lighting").Brightness ~= _G.NormalLightingSettings.Brightness then
                    _G.NormalLightingSettings.Brightness = game:GetService("Lighting").Brightness
                    if not _G.FullBrightEnabled then
                       repeat
                          wait()
                       until _G.FullBrightEnabled
                    end
                    game:GetService("Lighting").Brightness = 1
                 end
                 end)
         
                 game:GetService("Lighting"):GetPropertyChangedSignal("ClockTime"):Connect(function()
                 if game:GetService("Lighting").ClockTime ~= 12 and game:GetService("Lighting").ClockTime ~= _G.NormalLightingSettings.ClockTime then
                    _G.NormalLightingSettings.ClockTime = game:GetService("Lighting").ClockTime
                    if not _G.FullBrightEnabled then
                       repeat
                          wait()
                       until _G.FullBrightEnabled
                    end
                    game:GetService("Lighting").ClockTime = 12
                 end
                 end)
         
                 game:GetService("Lighting"):GetPropertyChangedSignal("FogEnd"):Connect(function()
                 if game:GetService("Lighting").FogEnd ~= 786543 and game:GetService("Lighting").FogEnd ~= _G.NormalLightingSettings.FogEnd then
                    _G.NormalLightingSettings.FogEnd = game:GetService("Lighting").FogEnd
                    if not _G.FullBrightEnabled then
                       repeat
                          wait()
                       until _G.FullBrightEnabled
                    end
                    game:GetService("Lighting").FogEnd = 786543
                 end
                 end)
         
                 game:GetService("Lighting"):GetPropertyChangedSignal("GlobalShadows"):Connect(function()
                 if game:GetService("Lighting").GlobalShadows ~= false and game:GetService("Lighting").GlobalShadows ~= _G.NormalLightingSettings.GlobalShadows then
                    _G.NormalLightingSettings.GlobalShadows = game:GetService("Lighting").GlobalShadows
                    if not _G.FullBrightEnabled then
                       repeat
                          wait()
                       until _G.FullBrightEnabled
                    end
                    game:GetService("Lighting").GlobalShadows = false
                 end
                 end)
         
                 game:GetService("Lighting"):GetPropertyChangedSignal("Ambient"):Connect(function()
                 if game:GetService("Lighting").Ambient ~= Color3.fromRGB(178, 178, 178) and game:GetService("Lighting").Ambient ~= _G.NormalLightingSettings.Ambient then
                    _G.NormalLightingSettings.Ambient = game:GetService("Lighting").Ambient
                    if not _G.FullBrightEnabled then
                       repeat
                          wait()
                       until _G.FullBrightEnabled
                    end
                    game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
                 end
                 end)
         
                 game:GetService("Lighting").Brightness = 1
                 game:GetService("Lighting").ClockTime = 12
                 game:GetService("Lighting").FogEnd = 786543
                 game:GetService("Lighting").GlobalShadows = false
                 game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
         
                 local LatestValue = true
                 spawn(function()
                 repeat
                    wait()
                 until _G.FullBrightEnabled
                 while wait() do
                    if _G.FullBrightEnabled ~= LatestValue then
                       if not _G.FullBrightEnabled then
                          game:GetService("Lighting").Brightness = _G.NormalLightingSettings.Brightness
                          game:GetService("Lighting").ClockTime = _G.NormalLightingSettings.ClockTime
                          game:GetService("Lighting").FogEnd = _G.NormalLightingSettings.FogEnd
                          game:GetService("Lighting").GlobalShadows = _G.NormalLightingSettings.GlobalShadows
                          game:GetService("Lighting").Ambient = _G.NormalLightingSettings.Ambient
                       else
                          game:GetService("Lighting").Brightness = 1
                          game:GetService("Lighting").ClockTime = 12
                          game:GetService("Lighting").FogEnd = 786543
                          game:GetService("Lighting").GlobalShadows = false
                          game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
                       end
                       LatestValue = not LatestValue
                    end
                 end
                 end)
              end
         
              _G.FullBrightExecuted = true
              _G.FullBrightEnabled = not _G.FullBrightEnabled
         end)
         
         VisualsPage:AddButton("Rainbow Gun", function()
            local c = 1
         function zigzag(X)
          return math.acos(math.cos(X * math.pi)) / math.pi
         end
         game:GetService("RunService").RenderStepped:Connect(function()
          if game.Workspace.Camera:FindFirstChild('Arms') then
           for i,v in pairs(game.Workspace.Camera.Arms:GetDescendants()) do
            if v.ClassName == 'MeshPart' then 
             v.Color = Color3.fromHSV(zigzag(c),1,1)
             c = c + .0001
            end
           end
          end
         end)
         end)
         
         
         
         
         --Misc
         
         
         MiscPage:AddBind("Toggle GUI", Enum.KeyCode.F8, function()
             ShowerLib:OpenClose() -- opens or closes the UI
         end)
         
         MiscPage:AddButton("Destroy GUI", function()
             ShowerLib:Destroy() -- Kills the GUI
         end)
         end
   if game.PlaceId == 5081773298 then
      Loaded = true
      --Made by : https://v3rmillion.net/member.php?action=profile&uid=1591342
    
   local ShowerLib = loadstring(game:HttpGet("https://fluxteam.xyz/scripts/others/ShowerHeadLibrary.lua"))()
   local ESP = loadstring(game:HttpGet"https://raw.githubusercontent.com/dawid-scripts/Helios-Hub/main/Scripts/HeliosESP.lua")()
   local Window = ShowerLib:CreateWindow("F"); --Clicking this will make it rotate.
   local HomePage = Window:Section("Auto-Farm")
   local SelfPage = Window:Section("Self")
   local VisualsPage = Window:Section("Visual")
   local MiscPage = Window:Section("Misc")
   ESP:SetESPColor(Color3.fromRGB(0, 166, 255))
   
   
   --Configuration
   local EggName = ""
   
   --Circle
   local FOVAmount = ""
   local CSides = ""
   
   --Configuration
   
   HomePage:AddToggle("Silent Aim", function(State)
      if State == true then
         local Players = game:GetService("Players")
         local LocalPlayer = Players.LocalPlayer
         local Mouse = LocalPlayer:GetMouse()
         local Network = require(LocalPlayer.PlayerScripts.GunFramework.InternalModules.network)
         
         function GetPlayer()
             local MaxDist, Player = math.huge
             for I,V in pairs(Players:GetPlayers()) do
                 if V == LocalPlayer then continue end
                 if V.Team == LocalPlayer then continue end
                 if not V.Character then continue end
                 local Head = V.Character:FindFirstChild("Head")
                 if not Head then continue end
                 local Pos, Vis = workspace.CurrentCamera:WorldToScreenPoint(Head.Position)
                 if not Vis then continue end
                 local MyPos, TheirPos = Vector2.new(Mouse.X, Mouse.Y), Vector2.new(Pos.X, Pos.Y)
                 local Dist = (TheirPos - MyPos).Magnitude
                 if Dist < MaxDist then
                     MaxDist = Dist
                     Player = V
                 end
             end
             return Player
         end
         Old = hookfunction(Network.send, function(self, ...)
             local Args = {...}
             if Args[1] == "bullet" then
                 local P = GetPlayer()
                 if P and P.Character and P.Character:FindFirstChild("Head") then
                     Args[2] = P.Character
                     Args[3] = P.Character.Head
                     Args[4] = P.Character.Head.Position
                     return Old(self, unpack(Args))
                 end
             end
             return Old(self, ...)
         end)
         for I,V in pairs(game:GetService("ReplicatedStorage").GunModules:GetChildren()) do
             pcall(function()
                 local a = require(V)
                 a.ReloadTime = 0
                 a.ClipSize = math.huge
                 a.FireRate = 0
                 a.Automatic = true
             end)
         end
         hookfunction(require(LocalPlayer.PlayerScripts.GunFramework.Recoil).ShootRecoil, function() end)
         local F = getconnections(game:GetService("LogService").MessageOut)[2].Function
         debug.setupvalue(F, 1, {})
         hookfunction(F, function() end)
      else
         local Players = game:GetService("Players")
         local LocalPlayer = Players.LocalPlayer
         local Mouse = LocalPlayer:GetMouse()
         local Network = require(LocalPlayer.PlayerScripts.GunFramework.InternalModules.network)
         
         function GetPlayer()
             local MaxDist, Player = math.huge
             for I,V in pairs(Players:GetPlayers()) do
                 if V == LocalPlayer then continue end
                 if V.Team == LocalPlayer then continue end
                 if not V.Character then continue end
                 local Head = V.Character:FindFirstChild("Head")
                 if not Head then continue end
                 local Pos, Vis = workspace.CurrentCamera:WorldToScreenPoint(Head.Position)
                 if not Vis then continue end
                 local MyPos, TheirPos = Vector2.new(Mouse.X, Mouse.Y), Vector2.new(Pos.X, Pos.Y)
                 local Dist = (TheirPos - MyPos).Magnitude
                 if Dist < MaxDist then
                     MaxDist = Dist
                     Player = V
                 end
             end
             return Player
         end
         Old = hookfunction(Network.send, function(self, ...)
             local Args = {...}
             if Args[1] == "bullet" then
                 local P = GetPlayer()
                 if P and P.Character and P.Character:FindFirstChild("Head") then
                     Args[2] = P.Character
                     Args[3] = P.Character.Head
                     Args[4] = P.Character.Head.Position
                     return Old(self, unpack(Args))
                 end
             end
             return Old(self, ...)
         end)
         for I,V in pairs(game:GetService("ReplicatedStorage").GunModules:GetChildren()) do
             pcall(function()
                 local a = require(V)
                 a.ReloadTime = 0
                 a.ClipSize = math.huge
                 a.FireRate = 0
                 a.Automatic = true
             end)
         end
         hookfunction(require(LocalPlayer.PlayerScripts.GunFramework.Recoil).ShootRecoil, function() end)
         local F = getconnections(game:GetService("LogService").MessageOut)[2].Function
         debug.setupvalue(F, 1, {})
         hookfunction(F, function() end)
      end
   end)
   
   
   
   --Self
   SelfPage:AddSlider("Walkspeed", 16, 180, 10, function(Value)
       game:GetService("Players").LocalPlayer.Character.Humanoid.WalkSpeed = Value -- Value is the value of the slider
   end)
   
   SelfPage:AddButton("Fly", function()
      loadstring(game:HttpGet(('https://pastebin.com/raw/WxmvCLLH'),true))()
   end)
   
   --Visual
   VisualsPage:AddToggle("Box", function(state)
       ESP:BoxESPToggle(state)
   end)
   
   VisualsPage:AddToggle("Tracers", function(state)
       ESP:TracersToggle(state)
   end)
   
   VisualsPage:AddToggle("Names", function(state)
       ESP:NameESPToggle(state)
   end)
   
   VisualsPage:AddToggle("Teamcheck", function(state)
       ESP:TeamcheckToggle(state)
   end)
   
   VisualsPage:AddToggle("Chams", function(state)
       if state == true then
           local color = BrickColor.new(255, 0, 50)
           local transparency = 0
   
           local Players = game:GetService("Players")
           local function _ESP(c)
              repeat wait() until c.PrimaryPart ~= nil
                 for i,p in pairs(c:GetChildren()) do
                    if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                       if p:FindFirstChild("4329138913") then p.shit:Destroy() end
                       local a = Instance.new("BoxHandleAdornment",p)
                       a.Name = "4329138913"
                       a.Size = p.Size
                       a.Color = color
                       a.Transparency = transparency
                       a.AlwaysOnTop = true
                       a.Visible = true
                       a.Adornee = p
                       a.ZIndex = true
   
                    end
                 end
              end
              local function ESP()
                 for i,v in pairs(Players:GetChildren()) do
                    if v ~= game.Players.LocalPlayer then
                       if v.Character then
                          _ESP(v.Character)
                       end
                       v.CharacterAdded:Connect(function(chr)
                       _ESP(chr)
                       end)
                    end
                 end
                 Players.PlayerAdded:Connect(function(player)
                 player.CharacterAdded:Connect(function(chr)
                 _ESP(chr)
                 end)
                 end)
              end
              ESP()
   
   
   
           else
   
   
   
              local color = BrickColor.new(255, 0, 50)
              local transparency = 1
   
              local Players = game:GetService("Players")
              local function _ESP(c)
                 repeat wait() until c.PrimaryPart ~= nil
                    for i,p in pairs(c:GetChildren()) do
                       if p.ClassName == "Part" or p.ClassName == "MeshPart" then
                          if p:FindFirstChild("4329138913") then p.shit:Destroy() end
                          local a = Instance.new("BoxHandleAdornment",p)
                          a.Name = "4329138913"
                          a.Size = p.Size
                          a.Color = color
                          a.Transparency = transparency
                          a.AlwaysOnTop = true
                          a.Visible = true
                          a.Adornee = p
                          a.ZIndex = true
   
                       end
                    end
                 end
                 local function ESP()
                    for i,v in pairs(Players:GetChildren()) do
                       if v ~= game.Players.LocalPlayer then
                          if v.Character then
                             _ESP(v.Character)
                          end
                          v.CharacterAdded:Connect(function(chr)
                          _ESP(chr)
                          end)
                       end
                    end
                    Players.PlayerAdded:Connect(function(player)
                    player.CharacterAdded:Connect(function(chr)
                    _ESP(chr)
                    end)
                    end)
                 end
                 ESP()
              end
   end)
   
   VisualsPage:AddSlider("Radius", 100, 400, 10, function(Value)
       FOVAmount = Value -- Value is the value of the slider
   end)
   
   circle = Drawing.new("Circle")
   
   VisualsPage:AddToggle("View FOV", function(state)
       if state == true then
           circle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
           circle.Color = Color3.fromRGB(143, 59, 87)
           circle.Thickness = 1.5
           circle.NumSides = 100
           circle.Radius = FOVAmount
           circle.Visible = true
           circle.Filled = false
   
           local RunService = game:GetService("RunService")
           local player = game.Players.LocalPlayer
           local mouse = player:GetMouse()
           local gi=game:GetService('GuiService'):GetGuiInset();
   
           RunService.Heartbeat:Connect(function()
           circle.Position = Vector2.new(mouse.X, mouse.Y+gi.Y)
           end)
        else
           circle.Destroy()
        end
   end)
   
   VisualsPage:AddLabel("Map")
   
   VisualsPage:AddButton("Fullbright", function()
       if not _G.FullBrightExecuted then
   
           _G.FullBrightEnabled = false
   
           _G.NormalLightingSettings = {
              Brightness = game:GetService("Lighting").Brightness,
              ClockTime = game:GetService("Lighting").ClockTime,
              FogEnd = game:GetService("Lighting").FogEnd,
              GlobalShadows = game:GetService("Lighting").GlobalShadows,
              Ambient = game:GetService("Lighting").Ambient
           }
   
           game:GetService("Lighting"):GetPropertyChangedSignal("Brightness"):Connect(function()
           if game:GetService("Lighting").Brightness ~= 1 and game:GetService("Lighting").Brightness ~= _G.NormalLightingSettings.Brightness then
              _G.NormalLightingSettings.Brightness = game:GetService("Lighting").Brightness
              if not _G.FullBrightEnabled then
                 repeat
                    wait()
                 until _G.FullBrightEnabled
              end
              game:GetService("Lighting").Brightness = 1
           end
           end)
   
           game:GetService("Lighting"):GetPropertyChangedSignal("ClockTime"):Connect(function()
           if game:GetService("Lighting").ClockTime ~= 12 and game:GetService("Lighting").ClockTime ~= _G.NormalLightingSettings.ClockTime then
              _G.NormalLightingSettings.ClockTime = game:GetService("Lighting").ClockTime
              if not _G.FullBrightEnabled then
                 repeat
                    wait()
                 until _G.FullBrightEnabled
              end
              game:GetService("Lighting").ClockTime = 12
           end
           end)
   
           game:GetService("Lighting"):GetPropertyChangedSignal("FogEnd"):Connect(function()
           if game:GetService("Lighting").FogEnd ~= 786543 and game:GetService("Lighting").FogEnd ~= _G.NormalLightingSettings.FogEnd then
              _G.NormalLightingSettings.FogEnd = game:GetService("Lighting").FogEnd
              if not _G.FullBrightEnabled then
                 repeat
                    wait()
                 until _G.FullBrightEnabled
              end
              game:GetService("Lighting").FogEnd = 786543
           end
           end)
   
           game:GetService("Lighting"):GetPropertyChangedSignal("GlobalShadows"):Connect(function()
           if game:GetService("Lighting").GlobalShadows ~= false and game:GetService("Lighting").GlobalShadows ~= _G.NormalLightingSettings.GlobalShadows then
              _G.NormalLightingSettings.GlobalShadows = game:GetService("Lighting").GlobalShadows
              if not _G.FullBrightEnabled then
                 repeat
                    wait()
                 until _G.FullBrightEnabled
              end
              game:GetService("Lighting").GlobalShadows = false
           end
           end)
   
           game:GetService("Lighting"):GetPropertyChangedSignal("Ambient"):Connect(function()
           if game:GetService("Lighting").Ambient ~= Color3.fromRGB(178, 178, 178) and game:GetService("Lighting").Ambient ~= _G.NormalLightingSettings.Ambient then
              _G.NormalLightingSettings.Ambient = game:GetService("Lighting").Ambient
              if not _G.FullBrightEnabled then
                 repeat
                    wait()
                 until _G.FullBrightEnabled
              end
              game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
           end
           end)
   
           game:GetService("Lighting").Brightness = 1
           game:GetService("Lighting").ClockTime = 12
           game:GetService("Lighting").FogEnd = 786543
           game:GetService("Lighting").GlobalShadows = false
           game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
   
           local LatestValue = true
           spawn(function()
           repeat
              wait()
           until _G.FullBrightEnabled
           while wait() do
              if _G.FullBrightEnabled ~= LatestValue then
                 if not _G.FullBrightEnabled then
                    game:GetService("Lighting").Brightness = _G.NormalLightingSettings.Brightness
                    game:GetService("Lighting").ClockTime = _G.NormalLightingSettings.ClockTime
                    game:GetService("Lighting").FogEnd = _G.NormalLightingSettings.FogEnd
                    game:GetService("Lighting").GlobalShadows = _G.NormalLightingSettings.GlobalShadows
                    game:GetService("Lighting").Ambient = _G.NormalLightingSettings.Ambient
                 else
                    game:GetService("Lighting").Brightness = 1
                    game:GetService("Lighting").ClockTime = 12
                    game:GetService("Lighting").FogEnd = 786543
                    game:GetService("Lighting").GlobalShadows = false
                    game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
                 end
                 LatestValue = not LatestValue
              end
           end
           end)
        end
   
        _G.FullBrightExecuted = true
        _G.FullBrightEnabled = not _G.FullBrightEnabled
   end)
   
   --Misc
   
   
   MiscPage:AddBind("Toggle GUI", Enum.KeyCode.F8, function()
       ShowerLib:OpenClose() -- opens or closes the UI
   end)
   
   MiscPage:AddButton("Destroy GUI", function()
       ShowerLib:Destroy() -- Kills the GUI
   end)
   
   
   
   
   
   
   
   
   else
      if Loaded == true then

      else
      local FLUXFALSEGAME = Instance.new("ScreenGui")
      local MainFrame = Instance.new("ImageLabel")
      local DropShadow = Instance.new("ImageLabel")
      local LoadScript = Instance.new("TextButton")
      local ButtonImage = Instance.new("ImageLabel")
      local DropShadow_2 = Instance.new("ImageLabel")
      local DuckLogo = Instance.new("ImageLabel")
      local DuckText = Instance.new("TextLabel")
      local HubText = Instance.new("TextLabel")
      local GameName = Instance.new("TextLabel")
      
      FLUXFALSEGAME.Name = "FLUX"
      FLUXFALSEGAME.Parent = game.CoreGui
      FLUXFALSEGAME.ResetOnSpawn = false
      
      MainFrame.Name = "MainFrame"
      MainFrame.Parent = FLUXFALSEGAME
      MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
      MainFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
      MainFrame.BackgroundTransparency = 1.000
      MainFrame.Position = UDim2.new(0.5,0,-1.2,0)
      MainFrame.Size = UDim2.new(0, 320, 0, 208)
      MainFrame.Image = "rbxassetid://3570695787"
      MainFrame.ImageColor3 = Color3.fromRGB(22, 22, 22)
      MainFrame.ScaleType = Enum.ScaleType.Slice
      MainFrame.SliceCenter = Rect.new(100, 100, 100, 100)
      MainFrame.SliceScale = 0.040
      
      DropShadow.Name = "DropShadow"
      DropShadow.Parent = MainFrame
      DropShadow.AnchorPoint = Vector2.new(0.5, 0.5)
      DropShadow.BackgroundTransparency = 1.000
      DropShadow.BorderSizePixel = 0
      DropShadow.Position = UDim2.new(0.5, 0, 0.5, 1)
      DropShadow.Size = UDim2.new(1, 18, 1, 18)
      DropShadow.ZIndex = 0
      DropShadow.Image = "rbxassetid://1316045217"
      DropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
      DropShadow.ImageTransparency = 0.600
      DropShadow.ScaleType = Enum.ScaleType.Slice
      DropShadow.SliceCenter = Rect.new(10, 10, 118, 118)
      
      LoadScript.Name = "LoadScript"
      LoadScript.Parent = MainFrame
      LoadScript.BackgroundColor3 = Color3.fromRGB(0, 174, 255)
      LoadScript.BackgroundTransparency = 1.000
      LoadScript.BorderSizePixel = 0
      LoadScript.Position = UDim2.new(0.078125, 0, 0.809807718, 0)
      LoadScript.Size = UDim2.new(0, 270, 0, 30)
      LoadScript.ZIndex = 4
      LoadScript.Font = Enum.Font.Gotham
      LoadScript.Text = "Load Script"
      LoadScript.TextColor3 = Color3.fromRGB(255, 255, 255)
      LoadScript.TextSize = 14.000
      
      ButtonImage.Name = "ButtonImage"
      ButtonImage.Parent = LoadScript
      ButtonImage.Active = true
      ButtonImage.AnchorPoint = Vector2.new(0.5, 0.5)
      ButtonImage.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
      ButtonImage.BackgroundTransparency = 1.000
      ButtonImage.Position = UDim2.new(0.5, 0, 0.5, 0)
      ButtonImage.Selectable = true
      ButtonImage.Size = UDim2.new(1, 0, 1, 0)
      ButtonImage.ZIndex = 3
      ButtonImage.Image = "rbxassetid://3570695787"
      ButtonImage.ImageColor3 = Color3.fromRGB(0, 174, 255)
      ButtonImage.ScaleType = Enum.ScaleType.Slice
      ButtonImage.SliceCenter = Rect.new(100, 100, 100, 100)
      ButtonImage.SliceScale = 0.040
      
      DropShadow_2.Name = "DropShadow"
      DropShadow_2.Parent = LoadScript
      DropShadow_2.AnchorPoint = Vector2.new(0.5, 0.5)
      DropShadow_2.BackgroundTransparency = 1.000
      DropShadow_2.BorderSizePixel = 0
      DropShadow_2.Position = UDim2.new(0.5, 0, 0.5, 1)
      DropShadow_2.Size = UDim2.new(1, 18, 1, 18)
      DropShadow_2.ZIndex = 2
      DropShadow_2.Image = "rbxassetid://1316045217"
      DropShadow_2.ImageColor3 = Color3.fromRGB(0, 0, 0)
      DropShadow_2.ImageTransparency = 0.700
      DropShadow_2.ScaleType = Enum.ScaleType.Slice
      DropShadow_2.SliceCenter = Rect.new(10, 10, 118, 118)
      
      DuckLogo.Name = "DuckLogo"
      DuckLogo.Parent = MainFrame
      DuckLogo.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
      DuckLogo.BackgroundTransparency = 1.000
      DuckLogo.Position = UDim2.new(0.359375, 0, 0.0249999985, 0)
      DuckLogo.Size = UDim2.new(0, 90, 0, 90)
      DuckLogo.Image = "rbxassetid://6170947320"
      
      DuckText.Name = "DuckText"
      DuckText.Parent = DuckLogo
      DuckText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
      DuckText.BackgroundTransparency = 1.000
      DuckText.Position = UDim2.new(0.0274305344, 0, 0.99444443, 0)
      DuckText.Size = UDim2.new(0, 48, 0, 30)
      DuckText.Font = Enum.Font.Gotham
      DuckText.Text = "FLUX"
      DuckText.TextColor3 = Color3.fromRGB(255, 255, 255)
      DuckText.TextSize = 20.000
      
      HubText.Name = "HubText"
      HubText.Parent = DuckLogo
      HubText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
      HubText.BackgroundTransparency = 1.000
      HubText.Position = UDim2.new(0.560763836, 0, 0.99444443, 0)
      HubText.Size = UDim2.new(0, 36, 0, 30)
      HubText.Font = Enum.Font.Gotham
      HubText.Text = "V1"
      HubText.TextColor3 = Color3.fromRGB(37, 212, 94)
      HubText.TextSize = 20.000
      
      GameName.Name = "GameName"
      GameName.Parent = MainFrame
      GameName.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
      GameName.BackgroundTransparency = 1.000
      GameName.Position = UDim2.new(0.14618054, 0, 0.658482909, 0)
      GameName.Size = UDim2.new(0, 226, 0, 23)
      GameName.Font = Enum.Font.Gotham
      GameName.Text = "[Game Detected] Loading..."
      GameName.TextColor3 = Color3.fromRGB(255, 255, 255)
      GameName.TextSize = 15.000
      GameName.TextWrapped = true
      
      LoadScript.MouseEnter:Connect(function()
         game:GetService("TweenService"):Create(ButtonImage, TweenInfo.new(0.25), {ImageColor3 = Color3.fromRGB(0, 204, 255)}):Play()
      end)
      LoadScript.MouseLeave:Connect(function()
         game:GetService("TweenService"):Create(ButtonImage, TweenInfo.new(0.25), {ImageColor3 = Color3.fromRGB(0, 174, 255)}):Play()
      end)
      
      
      MainFrame:TweenPosition(UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Bounce, 1, false)
          GameName.Text = "[No Game Detected]..."
          LoadScript.Text = "Quit"
          LoadScript.MouseButton1Down:Connect(function()
              MainFrame:TweenPosition(UDim2.new(0.5,0,-1.2,0), Enum.EasingDirection.Out, Enum.EasingStyle.Bounce, 1, false)
              wait(1)
              FLUXFALSEGAME:Destroy()
          end)
          return
      
      LoadScript.MouseButton1Down:Connect(function()
          MainFrame:TweenPosition(UDim2.new(0.5,0,-1.2,0), Enum.EasingDirection.Out, Enum.EasingStyle.Bounce, 1, false)
          loadstring(Script)()
          wait(1)
          FLUXFALSEGAME:Destroy()
      end)  
   end    
   end
